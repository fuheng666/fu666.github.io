{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"面试题崔整理","slug":"面试题崔整理","date":"2021-01-06T11:34:18.000Z","updated":"2021-01-06T11:45:55.012Z","comments":true,"path":"2021/01/06/面试题崔整理/","link":"","permalink":"http://example.com/2021/01/06/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%B4%94%E6%95%B4%E7%90%86/","excerpt":"","text":"[TOC] 前端HTML/CSS1. BFC​ 块级元素格式化上下文，它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 触发条件： float的值不为none overflow的值不为visible display的值为table-cell、table-caption和inline-block、flex之一 position的值为absolute和fixed之一 当前元素转换为根元素（display：flow-root，对上下margin重叠无效） 布局规则： 浮动的元素会被父级计算高度（父级添加overflow:hidden触发了BFC） 非浮动元素不会覆盖浮动元素原有位置（非浮动元素加overflow：hidden触发了BFC，display：inline-block） margin-top不会传递给父级（父级触发了BFC） 两个相邻元素上下margin会重叠（给其中一个元素增加一个父级，然后给他的父级添加overflow：hidden触发BFC，给第二个子元素添加display：inline-block） 2.清除浮动给父元素添加声明overflow:hidden;(触发一个BFC)优点：简单 缺点：当前父元素下的其它子元素不能有定位，有定位（relative与absolute）的元素会被隐藏。 在浮动元素下方添加空div,并给该元素添加声明：div{clear:both; height:0; overflow:hidden;}优点：没有兼容问题，除了IE7及以下。缺点：结构里会有很多无用的空标签。 万能请除法：12345678.clearfix:after&#123; content: &quot;&quot;; display: block; visibility: hidden; clear: both; height: 0; overflow: hidden;&#125; 优点：可以创建公共类选择器，多次使用。 缺点：不能兼容IE7及以下。代码有点多。对于IE7及以下浏览器版本高度坍塌添加zoom：1；可以解决高度坍塌问题。 3.css兼容性 -moz代表firefox浏览器私有属性 -ms代表IE浏览器私有属性 -webkit代表chrome、safari私有属性 -o代表opera私有属性 对于书写顺序一定要注意，兼容性写法放到前面，把标准写法放到最后 4.代码如何优化5.怎么优化网页 1. 尽可能的减少 HTTP 的请求数 content 2. 使用 CDN（Content Delivery Network）：根据离你最近的站点进行请求。 server 3. 添加 Expires 头(或者 Cache-control ) server 4. Gzip 组件 server 5. 将 CSS 样式放在页面的上方 css 6. 将脚本移动到底部（包括内联的） javascript 7. 避免使用 CSS 中的 Expressions css 8. 将 JavaScript 和 CSS 独立成外部文件 javascript css 9. 减少 DNS 查询 content 10. 压缩 JavaScript 和 CSS (包括内联的) javascript css 11. 避免重定向 server 12. 移除重复的脚本 javascript 13. 配置实体标签（ETags） css 14. 使 AJAX 缓存 6.css3新的技术一、2D效果属性要使用这些属性，我们需要通过 transform ，并且，为了保证兼容性，我们可能还需要添加带有浏览器内核前缀的属性，比如 -webkit-transform。1、位移属性 translate( x , y ) 1231、border-radius的值可以为绝对单位px，和相对单位em，rem，也可以为百分比，值越大，弧度越大。 2、属性值位数不同时，表现也不同，具体可以参考图片。 3、你也可以设置单个角的弧度，比如border-top-right-radius:5px；border-bottom-left-radius:5px。 1.2 box-shadow 阴影 1231、box-shadow: X轴偏移值 Y轴偏移值 X轴阴影模糊半径 Y轴阴影模糊半径 阴影颜色; 2、其中，X轴和Y轴的偏移值可以为负，但不能共用一个，X轴和Y轴的阴影半径可以共用一个，但是不能为负。 3、还需要注意的是，阴影模糊半径是可以不写的，比如box-shadow：10px 10px #ccc；这样，仍然会有阴影，但是就失去了这种模糊朦胧的效果，立体感也大大减弱了，一般不会这么使用。 1.3 box-sizing 属性允许你以特定的方式定义匹配某个区域的特定元素，这话有点绕口，我们结合图来说明。 12345box-sizing:content-box&#x2F;border-box&#x2F;inherit盒模型基本结构如图，当我们设置了宽高，使用了box-sizing属性， 属性值为content-box时，宽高的值为content的宽高； 属性值为border-box时（事实上我们比较常用的就是这个），宽高的值为border+padding+content也就是整个盒模型的宽高； 属性值为inherit时，则从父元素继承box-sizing的值。 二、背景CSS3中，我们对背景有了更强的控制 2.1 background-image跟以前不同的是，我们通过background-image来为一个元素添加多张图片，让我们结合代码和效果图来看一下。 1&lt;div class&#x3D;&quot;box&quot;&gt;&lt;&#x2F;div&gt;&#x2F;*右下角的小图为bg_flower.gif*&#x2F; 123456789.box&#123; height: 500px; width: 800px; margin: 0 auto; margin-top: 100px; background-image: url(img&#x2F;bg_flower.gif), url(img&#x2F;2.jpg);&#x2F;*写在前面的背景图会在上面*&#x2F; background-position: right bottom, left top;&#x2F;*默认为left top*&#x2F; background-repeat: no-repeat, repeat;&#x2F;*默认为repeat*&#x2F;&#125; 2.2 background-size 调整背景图片的大小属性值可以为实际单位，也可以是百分比。 1234.box&#123; background-size:60px 100px;/*宽，高*/ background-size:60% 100%;&#125; 2.3 background-origin 规定背景图片的定位区域1background-origin: content-box / padding-box / border-box ; 下图中，绿色的是边框，黄色的是padding+content区域。 123&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box3&quot;&gt;&lt;/div&gt; 123456789101112131415161718192021div&#123; float:left; margin:30px; width: 120px; height: 150px; background: yellow; border: 20px solid green; padding: 20px; background-image: url(img/bg_flower.gif); background-repeat: no-repeat;&#125;.box1&#123; background-origin:content-box;&#125;.box2&#123; background-origin:padding-box;&#125;.box3&#123; background-origin:border-box;&#125; 2.4 background-clip 规定背景的绘制区域1background-clip: content-box &#x2F; padding-box &#x2F; border-box ; 123&lt;div class=&quot;box1&quot;&gt;啦啦啦啦，德玛西亚。啦啦啦啦，剑圣偷塔。啦啦啦啦，我要回家。啦啦啦啦，下雨不怕。啊啊！&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;啦啦啦啦，德玛西亚。啦啦啦啦，剑圣偷塔。啦啦啦啦，我要回家。啦啦啦啦，下雨不怕。啊啊！&lt;/div&gt;&lt;div class=&quot;box3&quot;&gt;啦啦啦啦，德玛西亚。啦啦啦啦，剑圣偷塔。啦啦啦啦，我要回家。啦啦啦啦，下雨不怕。啊啊！&lt;/div&gt; 12345678910111213141516171819div&#123; float:left; margin:30px; width: 120px; height: 150px; background: yellow; border: 20px solid rgba(0, 0, 0, 0.1); padding: 20px;&#125;.box1&#123; background-clip:content-box;&#125;.box2&#123; background-clip:padding-box;&#125;.box3&#123; background-clip:border-box;&#125; 2.5 linear-gradient 背景的颜色渐变（IE10）​ CSS3 渐变（gradients）可以让你在两个或多个指定的颜色之间显示平稳的过渡。以前，你必须使用图像来实现这些效果。但是，通过使用 CSS3 渐变（gradients），你可以减少下载的事件和宽带的使用。此外，渐变效果的元素在放大时看起来效果更好，因为渐变（gradient）是由浏览器生成的。``其中颜色可以用多种表现形式，包括带有透明度的rgba()形式 1） 线性渐变 下面让我们来看代码 123456&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box3&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box4&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box5&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box6&quot;&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445div&#123; float:left; margin:30px; width: 100px; height: 150px; border: 2px solid orange; font-size: 14px; line-height: 1.5;&#125;.box1&#123;/* 1、属性值最少为两种颜色 */ background: -webkit-linear-gradient(red, yellow); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(red, yellow); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(red, yellow); /* Firefox 3.6 - 15 */ background: linear-gradient(red, yellow); /* 标准的语法 */&#125;.box2&#123;/* 2、可以设置颜色渐变的方向，比如从左到右 */ background: -webkit-linear-gradient(left, green , yellow); background: -o-linear-gradient(left, green, yellow); background: -moz-linear-gradient(left, green, yellow); background: linear-gradient(left, green , yellow);&#125;.box3&#123;/* 3、也可以沿着对角的方向渐变 */ background: -webkit-linear-gradient(top left, blue , yellow); background: -o-linear-gradient(top left, blue, yellow); background: -moz-linear-gradient(top left, blue, yellow); background: linear-gradient(top left, blue , yellow);&#125;.box4&#123;/* 4、或者，我们直接用角度确定渐变的方向（12点钟方向为0deg） */ background: -webkit-linear-gradient(60deg, rgb(248, 182, 44), rgb(0, 159, 233)); background: -o-linear-gradient(60deg, rgb(248, 182, 44), rgb(0, 159, 233)); background: -moz-linear-gradient(60deg, rgb(248, 182, 44), rgb(0, 159, 233)); background: linear-gradient(60deg, rgb(248, 182, 44), rgb(0, 159, 233));&#125;.box5&#123;/* 5、我们也可以定义多种颜色的渐变，之前的方向的设置方法不变 */ background: -webkit-linear-gradient(45deg,red,orange,yellow,green,blue,indigo,violet); background: -o-linear-gradient(45deg,red,orange,yellow,green,blue,indigo,violet); background: -moz-linear-gradient(45deg,red,orange,yellow,green,blue,indigo,violet); background: linear-gradient(45deg, red,orange,yellow,green,blue,indigo,violet);&#125;.box6&#123;/* 6、当然，渐变可以是很多次的 */ background: -webkit-repeating-linear-gradient(red, red 10%, yellow 20%); background: -o-repeating-linear-gradient(red, red 10%, yellow 20%); background: -moz-repeating-linear-gradient(red, red 10%, yellow 20%); background: repeating-linear-gradient(red, red 10%, yellow 20%);&#125; 2）径向渐变 ​ 创建一个径向渐变，你也必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以指定渐变的中心、形状（原型或椭圆形）、大小。&lt;br&gt;默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。 下面上代码 12345&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box3&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box4&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box5&quot;&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839div&#123; float:left; margin:30px; width: 150px; height: 150px; border: 2px solid orange; font-size: 14px; line-height: 1.5;&#125;.box1&#123;/* 1、颜色结点均匀分布（默认情况下 */ background: -webkit-radial-gradient(red, yellow, green); /* Safari 5.1 - 6.0 */ background: -o-radial-gradient(red, yellow, green); /* Opera 11.6 - 12.0 */ background: -moz-radial-gradient(red, yellow, green); /* Firefox 3.6 - 15 */ background: radial-gradient(red, yellow, green); /* 标准的语法 */ &#125;.box2&#123;/* 2、当然，对于颜色发辐射界限，我们也可以进行设置 */ background: -webkit-radial-gradient(red 5%, yellow 15%, green 60%); background: -o-radial-gradient(red 5%, yellow 15%, green 60%); background: -moz-radial-gradient(red 5%, yellow 15%, green 60%); background: radial-gradient(red 5%, yellow 15%, green 60%); &#125;.box3&#123;/* 3、shape 参数定义了形状。它可以是值 circle 或 ellipse。其中，circle 表示圆形，ellipse 表示椭圆形。 默认值是 ellipse。*/ background: -webkit-radial-gradient(circle, red, yellow, green); background: -o-radial-gradient(circle, red, yellow, green); background: -moz-radial-gradient(circle, red, yellow, green); background: radial-gradient(circle, red, yellow, green); &#125;.box4&#123;/* 4、size 参数定义了渐变的大小。它可以是以下四个值：closest-side farthest-side closest-corner farthest-corner，具体的不同大家可以自己尝试，这里只展示一种情况 */ background: -webkit-radial-gradient(60% 55%, closest-side,blue,green,yellow,black); background: -o-radial-gradient(60% 55%, closest-side,blue,green,yellow,black); background: -moz-radial-gradient(60% 55%, closest-side,blue,green,yellow,black); background: radial-gradient(60% 55%, closest-side,blue,green,yellow,black);&#125;.box5&#123;/* 5、当然，也是有重复渐变这种情况*/ background: -webkit-repeating-radial-gradient(red, yellow 10%, green 15%); background: -o-repeating-radial-gradient(red, yellow 10%, green 15%); background: -moz-repeating-radial-gradient(red, yellow 10%, green 15%); background: repeating-radial-gradient(red, yellow 10%, green 15%);&#125; 三、文本3.1 text-shadow 文本阴影​ 规则跟box-shadow类似，text-shadow：X轴偏移值，Y轴偏移值，阴影模糊半径，颜色。在这里，需要注意的是，如果前三个数值写两个，比如text-shadow：5px 5px #ccc；会认为阴影模糊半径不存在，仍然有文字的重影，但是没有模糊的视觉效果了。 3.2 word-wrap | word-break 是否允许长单词换行，这两个可以一起使用word-wrap: normal(只允许断点字换行) | break-word(如果单词过长，截断强制换行) word-break: normal(浏览器默认的换行规则，一般是不允许长单词内部换行) | break-all（允许在单词内换行) | keep-all(只能在半角空格或连字符处换行); 1234&lt;div class=&quot;box1&quot;&gt;aaaaa aaaaaaaaaaaaaaaaaaa aaaaaaaaaaa aaaaaaaaaa&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;aaaaa aaaaaaaaaaaaaaaaaaa aaaaaaaaaaa aaaaaaaaaa&lt;/div&gt;&lt;div class=&quot;box3&quot;&gt;aaaaa aaaaaaaaaaaaaaaaaaa aaaaaaaaaaa aaaaaaaaaa&lt;/div&gt;&lt;div class=&quot;box4&quot;&gt;aaaaa aaaaaaaaaaaaaaaaaaa aaaaaaaaaaa aaaaaaaaaa&lt;/div&gt; 123456789101112131415161718192021div&#123; float:left; margin:30px; width: 100px; height: 150px; border: 2px solid rgba(0, 0, 0, 0.5); font-size: 14px; line-height: 1.5;&#125;.box1&#123; word-wrap: normal;&#125;.box2&#123; word-wrap: break-word;&#125;.box3&#123; word-break: keep-all;&#125;.box4&#123; word-break: break-all;&#125; 7.语义化标签1.header 与hgroup放在页面或布局的顶部，一般放置导航栏或标题，如： 123&lt;header&gt; &lt;h1&gt;信息科技有限公司&lt;/h1&gt;&lt;/header&gt; 一个文档中可以包含一对或者一对以上的标签。 标签的位置是次要的，不一定非要显示在页面的上方，我们可以为任何需要的区块标签添加元素，例如下面将要讲解的、等标签。 1234&lt;hgroup&gt; &lt;h1&gt;这是一篇介绍HTML 5语义化标签和更简洁的结构&lt;/h1&gt; &lt;h2&gt;HTML 5&lt;/h2&gt;&lt;/hgroup&gt; 如果有连续多个h1-h6标签就用hgroup 如果有连续多个标题和其他文章数据，h1-h6标签就用hgroup包住，和其他文章元数据一起放入header标签 2.nav表示页面的导航，也可以在标签中使用，还可以显示在侧边栏中。一个页面之中可以有多个标签。 为了方便搜索引擎解析，最好是将主要的链接放在nav中。 12345678910&lt;header&gt; &lt;h1&gt;**信息科技有限公司&lt;/h1&gt; &lt;nav&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;example.html&quot;&gt;客户案例&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;service_one.html&quot;&gt;技术服务&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;aboutus_one.html&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;connection.html&quot;&gt;联系我们&lt;/a&gt;&lt;/li&gt; &lt;/nav&gt;&lt;/header&gt; 3.aside所包含的内容不是页面的主要内容、具有独立性，是对页面的补充。 1&lt;aside&gt;一般使用在页面、文章的侧边栏、广告、友情链接等区域。 4.footer一般被放置在页面或者页面中某个区块的底部，包含版权信息、联系方式等信息。一个页面也可以有多个footer 12345&lt;footer&gt; &lt;small&gt; 版权所有 © 2016-2017 **信息科技有限公司 &lt;/small&gt;&lt;/footer&gt; 5.article1&lt;article&gt;元素应该使用在相对比较独立、完整的的内容区块，所以我们可以在一篇博客、一个论坛帖子、一篇新闻报道或者一个用户评论中使用&lt;article&gt;元素。article可以互相嵌套。 12345&lt;article&gt; &lt;h1&gt;HTML5学习之语义化标签&lt;/h1&gt; &lt;p&gt;....正文.....&lt;/p&gt; &lt;footer&gt;版权所有*伪版必究&lt;/footer&gt;&lt;/article&gt; 6.section一组或者一节内容。 12345&lt;div&gt;、&lt;section&gt;、&lt;article&gt;三者的比较：&lt;div&gt;：应用广泛，任意一个区域 &lt;section&gt;：包含的内容是一个明确的主题，通常有标题区域 &lt;article&gt;：如果我们的页面中需要一个单独的模块来实现一个单独的功能，就用&lt;article&gt;，其他的时候都用&lt;section&gt; 7.time可以带格式的时间标签 1&lt;time datetime=&quot;2017-07-03&quot;&gt; 8.mark高亮 9.addressaddress代表区块容器，必须是作为联系信息出现，邮编地址、邮件地址等等,一般出现在footer。 8.浏览器的兼容性问题https://www.cnblogs.com/angel648/p/11392262.html 9.如何垂直水平居中盒子1234567891011121314div&#123; position:absolute; top:0; left:0; right:0; bottom:0; margin:auto&#125;div&#123; position: absolute; left: 50%; /* 父盒子宽度的50% */ top: 50%; /* 父盒子高度的50% */ transform: translate(-50%,-50%); /* 子盒子自身宽高的50% */ &#125; 10.浏览器内核Trident 内核：IE，搜狗高速浏览器等 Gecko 内核：Mozilla Firefox（火狐浏览器），Netscape6及以上版本 Webkit 内核：Safari 、曾经的 Chrome Presto 内核：Opera 7到Opera12.17（欧朋浏览器）之间的版本采用的内核 Blink 内核：现在 Chrome 内核是 Blink，Opera现已改用Google Chrome的Blink内核 移动端1. 如何解决开发中的0.5像素问题？121px边框 dpr = 物理像素 / 逻辑像素 2border:1px solid #ccc 解决transform:scale(0.5) 2. rem适配rem：相对于根元素(即html元素)font-size计算值的倍数的一个css单位。特点：​ 1、只相对于根元素（html）​ 2、通过修改根元素可成比例的调整页面字体大小​ 3、其适配方案通过js脚本设置像素点来实现 em：是一个相对长度单位。其相对于当前对象内文本的字体尺寸。特点：​ 1、em的值并不是固定的​ 2、em会继承父级元素的字体大小 rem适配：​ iphone 6为例：​ width：375px 100px​ 视口： width ？ ​ document.documentElement.style.fontSize= document.documentElement.ClientWidth / 3.75 + ‘px’ vm+rem实现响应式布局屏幕标准宽375px，全部宽度是100vw，即 100vw / 375px = 0.2666667vw/px 123html&#123; font-size:26.6667vw!important;&#125; 屏幕标准宽750px，全部宽度是100vw，即 100vw / 750px= 0.1333333vw/px 123html&#123; font-size:13.3333vw!important;&#125; 3. 移动端设备单位ppi/dpi(每英寸所拥有像素点的数量)dpr：设备像素比（物理像素、逻辑像素）逻辑像素就是css设置的的像素物理像素就是设备显示的像素dpr== 物理像素/逻辑像素dpr 一般考虑的值：2或3如果移动端设计图的宽度为750/640 选择的dpr为2如果移动端设计图的宽度为1080 选择的dpr为3例： 如果设计图为640px dpr为2 如果从ps中量出元素宽度为300px; 在css里面设置的为 300px / dpr(2) == 150px; vw是可视窗口的宽度单位，和百分比有点一样，1vw=可视窗口的宽度的百分之一vh是可视窗口的高度单位，和百分比有点一样，1vh=可视窗口的高度的百分之一JavaScript1. cookie的使用，一般在什么位置使用cookie​ cookie主要把数据保存在浏览器。 像现在有些网站会把用户信息放在cookie 这样就不用每次都输入用户名密码登录了。类似这种信息都可以放cookie。 设置cookie document.cookie = 符合cookie格式的字符串。 读取cookie alert(document.cookie); 直接读取 包括： expires：失效时间 path：限制访问路径 domain：访问域名 secure：安全设置 封装cookie 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function $cookie(name)&#123; var argus = arguments; switch(argus.length)&#123; case 1: return getCookie(name); break; case 2: //如果是两个参数判断第二个参数是否是null if(argus[1] == null)&#123; removeCookie(name); &#125;else&#123; //如果不是，设置cookie 第三参数传入空对象，防止报错 setCookie(name, argus[1], &#123;&#125;); &#125; break; default: //三个参数 setCookie(...argus); break; &#125;&#125;function setCookie(name, value, &#123; expires, path, domain, secure &#125;) &#123; var cookieStr = encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value); if (expires) &#123; cookieStr += &quot;;expires=&quot; + afterOfDate(expires); &#125; if(path)&#123; cookieStr += &quot;;path=&quot; + path; &#125; if(domain)&#123; cookieStr += &quot;;domain=&quot; + domain; &#125; if(secure)&#123; cookieStr += &#x27;;secure&#x27;; &#125; document.cookie = cookieStr;&#125;function getCookie(name) &#123; var cookieStr = decodeURIComponent(document.cookie); var cookieArr = cookieStr.split(&quot;; &quot;); var reg = new RegExp(&quot;^&quot; + name + &quot;=&quot;); var res = cookieArr.find(item =&gt; reg.test(item)); if(!res)&#123; return null; &#125;else&#123; //name=value var arr = res.split(&quot;=&quot;); return arr[1]; &#125;&#125;function removeCookie(name) &#123; document.cookie = encodeURIComponent(name) + &quot;=;expires=&quot; + new Date(0);&#125;//获取n天后的时间function afterOfDate(n) &#123; var d = new Date(); var day = d.getDate(); d.setDate(day + n); return d;&#125; 2. cookie、localStorage、sessionStorage的区别？cookie: 最大能够存储4kb，每个域名下最多存储50条 可以设置存储的数据时间 都可以兼容 localStorage（本地化存储数据）： 最大能够存储5MB 永久存储 H5以后新特性 sessionStorage 最大能够存储5MB 只能存储一次会话（打开浏览器，关闭浏览器） H5以后新特性 3. 闭包定义：就是能够读取其他函数内部变量的函数。 必备条件： 有一个函数A , 在函数A内部返回一个函数B 在函数B 中访问函数A 的私有作用域变量 在函数A 外部,有变量引用函数B 特点： 让外部访问函数内部变量成为可能； 局部变量会常驻在内存中； 可以避免使用全局变量，防止全局变量污染； 会造成内存泄漏（有一块内存空间被长期占用，而不被释放） 引起内存泄漏？ 全局变量没定义 定时器开着没有及时清掉 闭包 js对象与dom对象相互引用着 双重for循环导致死循环问题 。 闭包的应用场景？封装功能时(需要使用私有的属性和方法)，函数防抖、函数节流、函数柯里化、给元素伪数组添加事件需要使用元素的索引值。 4. 函数防抖、函数节流、函数柯里化 函数防抖 12345678910111213141516171819202122232425262728// 在单位时间内，如果重复触发，只执行最后一次。// 非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。function antiShake(funcName,delay) &#123; var timer = null; return function () &#123; const content = this; const args = [...arguments]; if(timer) clearTimeout(timer); timer = setTimeout(function () &#123; funcName.apply(content,args); &#125;,delay) &#125;&#125;// 立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。function antiShake(funcName,delay) &#123; var timer = null; return function () &#123; const content = this; const args = [...arguments]; if(!timer)&#123; funcName.apply(content,args); timer = setTimeout(function()&#123; clearTimeout(timer); timer = null; &#125;,delay) &#125; &#125;&#125; 函数节流 12345678910111213141516171819202122232425262728293031// 指定时间间隔内只执行一次函数。// 函数节流：降频，将函数调用的频率降低// 时间戳版function throttle(funcName,delay)&#123; let preTime = Date.now(); return function()&#123; let content = this; lett args = [...arguments]; let curTime = Date.now(); if(curTime - preTime &gt;= delay)&#123; funcName.apply(content,args); preTime = curTime; &#125; &#125;&#125;// 定时器版function throttle(funcName,delay)&#123; var timer = null; return function()&#123; const content = this; const args = [...arguments]; if(!timer)&#123; timer = setTimeout(function()&#123; funcName.apply(content,args); clearTimeout(timer); timer = null; &#125; ,delay) &#125; &#125;&#125;// 我们应该可以很容易的发现，其实时间戳版和定时器版的节流函数的区别就是，时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。 • 函数柯里化 123456789101112131415161718//是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数。// 支持多参数传递function progressCurrying(fn, args) &#123; var _this = this var len = fn.length; var args = args || []; return function () &#123; // Array.prototype.slice.call(arguments)能将具有length属性的对象转成数组 var _args = Array.prototype.slice.call(arguments); Array.prototype.push.apply(args, _args); // 如果参数个数小于最初的fn.length，则递归调用，继续收集参数 if (_args.length &lt; len) &#123; return progressCurrying.call(_this, fn, _args); &#125; // 参数收集完毕，则执行fn return fn.apply(this, _args); &#125;&#125; 5. 浏览器渲染过程1. 浏览器将获取的HTML文档并解析成DOM树。 2. 处理CSS标记，构成层叠样式表模型CSSOM(CSS Object Model)。 3. 将DOM和CSSOM合并为渲染树(rendering tree)将会被创建，代表一系列将被渲染的对象。 4. 渲染树的每个元素包含的内容都是计算过的，它被称之为布局layout。浏览器使用一种流式处理的方法，只需要一次pass绘制操作就可以布局所有的元素。 5. 将渲染树的各个节点绘制到屏幕上，这一步被称为绘制painting. 6. 数组的常用方法1. 改变原数组： 数组方法 用法 push 可以接受任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。 pop 数组末尾移除最后一个项，减少数组的length值，然后返回移除的项。 shift 删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined。 unshift 向数组的开头添加一个或多个元素，并返回新的长度。 reverse 反转数组项的顺序 sort sort() 方法用于对数组的元素进行排序。1.如果不提供回调函数则是安字母升序 2.如果提供回调函数那么根据回调函数的返回值来排序，sort()将对数组最后一个元素以外的每个元素调用回调函数，回调函数需要有两个参数，第一个参数代表当前元素，第二个参数代表当前元素的后一个元素（因此不会对最后一个元素调用），根据情况一个元素可能会调用多次 splice index：必需。规定从何处添加/删除元素。 该参数是开始插入和（或）删除的数组元素的下标，必须是数字。howmany：可选。规定应该删除多少元素。必须是数字，但可以是 “0”。 如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。item1，…，itemX：可选。要添加到数组的新元素。 2. 不可改变原数组：forEach、filter、map、reduce、slice、concat、join 数组方法 定义 concat 用于连续两个数组或多个数组，仅会返回被连接数组的一个副本 join 返回一个字符串。该字符串是通过把arrayObject的每个元素转换为字符串，然后把字符串连接起来。 slice 返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。 ​ 数组遍历循环方法：注：都不会改变元素组 数组的map方法是进行数组的遍历，返回一个全新的数组，不会改变原来的数组。数组.map(function (item, index, arr) {}) 数组的reduce方法根据callback中的条件对数组中的每个元素都进行累加的操作，返回一个全新的值。 12345678arr.reduce(function(prev,cur,index,arr)&#123;...&#125;, init);arr 表示原数组；prev 表示上一次调用回调时的返回值，或者初始值 init;cur 表示当前正在处理的数组元素；index 表示当前正在处理的数组元素的索引，若提供 init 值，则索引为0，否则索引为1；init 表示初始值。 forEach()用于遍历数组，无返回值，不支持ie。数组.forEach(function (item, index, arr) {}) filter()用于过滤数组中满足条件的元素，返回一个过滤后的新数组。数组.filter(function (item, index, arr) {}) every()是对数组中的每一项运行给定函数，如果该函数对第一项返回true，则返回true。数组.every(function (item, index, arr) {}) some()是对数组中每一项运行指定函数，如果该函数对任一项返回true，则返回true、数组.some(function (item, index, arr) {}) ​ 7. 数组的去重？set reduce indexOf includes （4种) set 1let arr2 = Array.from(new Set(arr)) indexOf 123456let arr2 = []for(var i=0;i&lt;arr.length;i++)&#123; if(arr2.indexOf(arr[i]) === -1)&#123; arr2.push(arr[i]) &#125;&#125; reduce 1234let arr2 = arr.reduce((prev,cur)=&gt;&#123; prev.indexOf(cur) === -1 &amp;&amp; prev.push(cur) return prev&#125;,[]) map 12345678const map = new Map();const res = [];for (let i = 0; i &lt; arr.length; i++) &#123; if (!map.has(arr[i])) &#123; map.set(arr[i], true) res.push(arr[i]); &#125;&#125; 8. 字符串方法： 方法 定义 toLowerCase() 把字符串转为小写，返回新的字符串。 toUpperCase() 把字符串转为大写，返回新的字符串 charAt() 返回指定下标位置的字符。如果index不在0-str.length(不包含str.length)之间，返回空字符串。 charCodeAt() 返回指定下标位置的字符的unicode编码,这个返回值是 0 - 65535 之间的整数。注意：如果index不在0-str.length(不包含str.length)之间，返回NaN。 indexOf() 返回某个指定的子字符串在字符串中第一次出现的位置注意：indexOf()方法对大小写敏感，如果子字符串没有找到，返回-1。第二个参数表示从哪个下标开始查找，没有写则默认从下标0开始查找。 lastIndexOf() 返回某个指定的子字符串在字符串中最后出现的位置。注意：lastIndexOf()方法对大小写敏感，如果子字符串没有找到，返回-1。第二个参数表示从哪个下标开始查找，没有写则默认从最后一个字符处开始查找。 substring(): 提取字符串中介于两个指定下标之间的字符。注意：substring()用法与slice()一样，但不接受负值的参数。 substr(): 返回从指定下标开始指定长度的的子字符串。注意：如果没有指定length,返回从下标开始处结尾处的所有字符串。 split() 把字符串分割成字符串数组。 replace() 在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 match() 返回所有查找的关键字内容的数组。 ​ 9. js中的数据类型：​ 基本数据类型（存放在栈中）：Number String boolean Null undefind symbol(es6新增) ​ 引用数据类型（存放在堆中）：Object 10. 判断是否是数组？ 通过instanceof判断instanceof运算符用于检验构造函数的prototype属性是否出现在对象的原型链中的任何位置，返回一个布尔值。let a = [];a instanceof Array; //truelet b = {};b instanceof Array; //false存在问题：需要注意的是，prototype属性是可以修改的，所以并不是最初判断为true就一定永远为真。 通过constructor判断实例的构造函数属性constructor指向构造函数，那么通过constructor属性也可以判断是否为一个数组。let a = [1,3,4];a.constructor === Array;//true同样，这种判断也会存在多个全局环境的问题，导致的问题与instanceof相同。 通过Object.prototype.toString.call()判断Object.prototype.toString().call()可以获取到对象的不同类型，例如let a = [1,2,3]Object.prototype.toString.call(a) === ‘[object Array]’;//true对于多个全局环境中也能实现 通过Array.isArray()判断Array.isArray() 用于确定传递的值是否是一个数组，返回一个布尔值。let a = [1,2,3]Array.isArray(a);//true对于多个全局环境，也可以准确判断推荐：Array.isArray() 11. 面向对象编程与面向过程编程的区别？​ 面向过程编程就是一步一步的按照过程来进行，面向流程的；简单来说就是先分析出解决问题所需要的步骤，然后用函数一步步的调用实现。面向过程编程是一种直接的编程方法，它是按照编程语言的思路考虑问题，比如C语言这种过程式语言。 ​ 面向对象编程是面向问题中的各种独立个体的，将程序分解为不同对象之间交互的过程。面向对象编程强调’封装‘，’继承‘，’多态‘等，数据和数据相关的操作被包装为对象，每一种对象是相对完成和独立的… 12. this指向问题？this指代是【当前对象】所谓的当前对象，是指，此刻正在执行这个函数的对象，谁调用这个函数，this执行谁。 全局对象指向window。 对象方法中指向该对象。 事件绑定中指向目标对象。 一般是：对象.方法()call：方法.call(对象)Person.call(document);//document.Person();this：document call/apply/bind的区别?call(,value1,value2)/apply(,[value1,value2])函数.call(指定任何对象); //可以直接执行函数let 新函数 = 函数.bind(obj); new:1、创建一个空对象，将它的引用赋给 this，继承函数的原型。2、通过 this 将属性和方法添加至这个对象3、最后返回 this 指向的新对象，也就是实例 12345678910111213141516function Human()&#123; //var obj = &#123;&#125;; //this=obj; this.name = &quot;xxx&quot;; //等价于obj.name = &quot;xxx&quot; //return obj;&#125;//封装bind？Function.prototype.bind = function(target)&#123; var fn = this return function()&#123; fn.apply(target,arguments) &#125;&#125; 13. eval函数是做什么的？eval只是一个普通的函数，只不过他有一个快速通道通向编译器，可以将string变成可执行的代码。严格模式下：eval是一个单独的作用域。缺点： 可读性非常差 不好再做优化和编译 会轻微增加性能消耗 不安全，比如 eval input 的值 14. 作用域链是什么？什么是作用域？在 Javascript 中，作用域分为 全局作用域 和 函数作用域 全局作用域：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。 函数作用域：在固定的代码片段才能被访问变量取值：到创建 这个变量 的函数的作用域中取值 作用域链？一般情况下，变量取值到创建这个变量的函数的作用域中取值。但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。 15. 原型链继承的机制是什么？js的默认继承是什么？call()apply()prototype js中万物皆对象，每个对象都有一个隐式原型proto ，指向创建它的构造函数的原型对象。 函数（构造函数）除了有一个隐式原型对象，还有一个属性prototype，它指向一个对象，这个对象就是原型对象，也叫显式原型。 原型对象有一个属性constructor，它指向这个构造函数本身。 而原型链，就是为了实现js的继承，把实例对象的__proto__属性一层一层的指向它的构造函数的原型对象，直到它（Object.prototype）的原型对象为null。 16. 垃圾回收（GC）机制是什么？​ 释放垃圾占用的空间，防止内存泄露。有效的使用可以使用的内存，对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。 ​ 标记清除(mark-and-sweep)：是对于脱离作用域的变量进行回收，当进入作用域时，进行标记，离开作用域时，标记并回收这些变量。 ​ 引用计数：引用计数是跟踪记录每个值被引用的次数。就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象，每当过一段时间开始垃圾回收的时候，就把被引用数为0的变量回收。引用计数方法可能导致循环引用，类似死锁，导致内存泄露。 17. 深拷贝和浅拷贝？浅拷贝：可以讲对象的最外层属性全部复制，里层属性仍然是引用关系。拷贝的只是引用，修改拷贝后的数据会影响原来的数据，使得数据不安全。这种拷贝方式也称为浅拷贝。方法： object.assign for循环 展开运算符 浅拷贝的应用场景？对于一层结构的Array和Object想要拷贝一个副本时使用 深拷贝：拷贝多层，每一级别的数据都会拷贝，拷贝后会生成一份新的数据，修改拷贝后的数据不会影响原来的数据。方法： JSON.parse(JSON.stringify(obj))。 通过递归实现深拷贝。 123456789101112131415161718function deepClone(obj) &#123; //判断拷贝的要进行深拷贝的是数组还是对象，是数组的话进行数组拷贝，对象的话进行对象拷贝 var objClone = Array.isArray(obj) ? [] : &#123;&#125;; //进行深拷贝的不能为空，并且是对象或者是 if (obj &amp;&amp; typeof obj === &quot;object&quot;) &#123; for (key in obj) &#123; //判断obj中是否有key这个键 if (obj.hasOwnProperty(key)) &#123; if (obj[key] &amp;&amp; typeof obj[key] === &quot;object&quot;) &#123; objClone[key] = deepClone(obj[key]); &#125; else &#123; objClone[key] = obj[key]; &#125; &#125; &#125; &#125; return objClone;&#125; lodash.js中_.cloneDeep(value) 深拷贝应用场景？复制深层次的object数据结构 18. 事件循环 Event loopEvent Loop是一个程序结构，用于等待和发送消息和事件。 在JavaScript中，任务被分为两种，一种宏任务（MacroTask）也叫Task，一种叫微任务（MicroTask）。 MacroTask（宏任务） script全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。 MicroTask（微任务） Process.nextTick（Node独有）、Promise.then()、Object.observe(废弃)、MutationObserver（具体使用方式查看这里） 浏览器中的Event Loop Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。 JS调用栈 JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。 同步任务和异步任务 Javascript单线程任务被分为同步任务和异步任务，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。 任务队列Task Queue，即队列，是一种先进先出的一种数据结构。 事件循环的进程模型 选择当前要执行的任务队列，选择任务队列中最先进入的任务，如果任务队列为空即null，则执行跳转到微任务（MicroTask）的执行步骤。 将事件循环中的任务设置为已选择任务。 执行任务。 将事件循环中当前运行任务设置为null。 将已经运行完成的任务从任务队列中删除。 microtasks步骤：进入microtask检查点。 更新界面渲染。 返回第一步。 执行进入microtask检查点时，用户代理会执行以下步骤： 设置microtask检查点标志为true。 当事件循环microtask执行不为空时：选择一个最先进入的microtask队列的microtask，将事件循环的microtask设置为已选择的microtask，运行microtask，将已经执行完成的microtask为null，移出microtask中的microtask。 清理IndexDB事务 设置进入microtask检查点的标志为false。 上述可能不太好理解，下图是我做的一张图片。 执行栈在执行完同步任务后，查看执行栈是否为空，如果执行栈为空，就会去执行Task（宏任务），每次宏任务执行完毕后，检查微任务(microTask)队列是否为空，如果不为空的话，会按照先入先出的规则全部执行完微任务(microTask)后，设置微任务(microTask)队列为null，然后再执行宏任务，如此循环。 19. 什么是堆和栈？栈（stack）：由编译器自动分配释放，存放函数的参数值，局部变量等。 堆（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统释放。 20. 栈和队列的区别？栈是后进先出的数据结构，常用的比如调用栈。 队列是先进先出的数据结构，常用的就是NodeJS和浏览器的任务队列。 21. 同步和异步？串行和并行？单个程序的运动状态： 同步：阻塞执行，当前的程序要执行，必须等前面的程序执行完毕再去执行，否则阻塞。 异步：非阻塞执行，当前的程序是否执行和前面的程序是否执行完毕没有直接关系。 多个程序之前的状态： 串行：A执行完毕以后，再去执行B，一次类推，按照顺序执行 。 并行：A，B，C等多个程序可以同时进行，或者随意执行。 同步串行，异步串行，异步并行 22. 重绘与重排重绘：一个元素外观的改变所触发的浏览器行为。例如改变outline、背景色等属性，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观，重绘不会带来重新布局，所以不一定伴随重排。 重绘何时发生： 当 render tree 中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的，比如 background-color，则称之为重绘 改变字体 增加或者移除样式表 内容变化，比如用户在input框中输入文字 激活CSS伪类(:hover) 脚本操作DOM （也有可能造成回流 计算 offsetWidth 和 offsetHeight 的属性 设置style属性的值 重排：渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程叫做布局或重排。 下述情况会发生浏览器重排 添加或者删除可见的DOM元素 元素位置改变 元素尺寸改变（包括：内外边距、边框厚度、宽度和高度等属性的改变） 内容改变，例如：文本改变或者图片被另一个不同尺寸的图片替代 页面渲染器初始化 浏览器窗口尺寸改变 对可见元素 display：none，或者对不可见元素 display：block 时 激活伪类(:hover) transition对宽高的处理，在整个transition的每一帧中，浏览器都要去重新布局，绘制页面。 23.事件循环Event Loop是一个程序结构，用于等待和发送消息和事件。 在JavaScript中，任务被分为两种，一种宏任务（MacroTask）也叫Task，一种叫微任务（MicroTask）。 MacroTask（宏任务） script全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。 MicroTask（微任务） Process.nextTick（Node独有）、Promise.then()、Object.observe(废弃)、MutationObserver（具体使用方式查看这里） 浏览器中的Event Loop Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。 JS调用栈 JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。 同步任务和异步任务 Javascript单线程任务被分为同步任务和异步任务，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。 任务队列Task Queue，即队列，是一种先进先出的一种数据结构。 事件循环的进程模型 选择当前要执行的任务队列，选择任务队列中最先进入的任务，如果任务队列为空即null，则执行跳转到微任务（MicroTask）的执行步骤。 将事件循环中的任务设置为已选择任务。 执行任务。 将事件循环中当前运行任务设置为null。 将已经运行完成的任务从任务队列中删除。 microtasks步骤：进入microtask检查点。 更新界面渲染。 返回第一步。 执行进入microtask检查点时，用户代理会执行以下步骤： 设置microtask检查点标志为true。 当事件循环microtask执行不为空时：选择一个最先进入的microtask队列的microtask，将事件循环的microtask设置为已选择的microtask，运行microtask，将已经执行完成的microtask为null，移出microtask中的microtask。 清理IndexDB事务 设置进入microtask检查点的标志为false。 上述可能不太好理解，下图是我做的一张图片。 执行栈在执行完同步任务后，查看执行栈是否为空，如果执行栈为空，就会去执行Task（宏任务），每次宏任务执行完毕后，检查微任务(microTask)队列是否为空，如果不为空的话，会按照先入先出的规则全部执行完微任务(microTask)后，设置微任务(microTask)队列为null，然后再执行宏任务，如此循环。 24.数组扁平化数组扁平化是指将一个多维数组变为一个一维数组 12const arr = [1, [2, [3, [4, 5]]], 6];// =&gt; [1, 2, 3, 4, 5, 6] 方法一：使用flat()1const res1 = arr.flat(Infinity); 方法二：利用正则1const res2 = JSON.stringify(arr).replace(/\\[|\\]/g, &#x27;&#x27;).split(&#x27;,&#x27;); 但数据类型都会变为字符串 方法三：正则改良版本1const res3 = JSON.parse(&#x27;[&#x27; + JSON.stringify(arr).replace(/\\[|\\]/g, &#x27;&#x27;) + &#x27;]&#x27;); 方法四：使用reduce123456const flatten = arr =&gt; &#123; return arr.reduce((pre, cur) =&gt; &#123; return pre.concat(Array.isArray(cur) ? flatten(cur) : cur); &#125;, [])&#125;const res4 = flatten(arr); 方法五：函数递归1234567891011const res5 = [];const fn = arr =&gt; &#123; for (let i = 0; i &lt; arr.length; i++) &#123; if (Array.isArray(arr[i])) &#123; fn(arr[i]); &#125; else &#123; res5.push(arr[i]); &#125; &#125;&#125;fn(arr); 25.重绘与重排重绘：一个元素外观的改变所触发的浏览器行为。例如改变outline、背景色等属性，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观，重绘不会带来重新布局，所以不一定伴随重排。 重绘何时发生： 当 render tree 中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的，比如 background-color，则称之为重绘 改变字体 增加或者移除样式表 内容变化，比如用户在input框中输入文字 激活CSS伪类(:hover) 脚本操作DOM （也有可能造成回流 计算 offsetWidth 和 offsetHeight 的属性 设置style属性的值 重排：渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程叫做布局或重排。 下述情况会发生浏览器重排 添加或者删除可见的DOM元素 元素位置改变 元素尺寸改变（包括：内外边距、边框厚度、宽度和高度等属性的改变） 内容改变，例如：文本改变或者图片被另一个不同尺寸的图片替代 页面渲染器初始化 浏览器窗口尺寸改变 对可见元素 display：none，或者对不可见元素 display：block 时 激活伪类(:hover) transition对宽高的处理，在整个transition的每一帧中，浏览器都要去重新布局，绘制页面。 26.一元 二元 三元一元：++ – 使用：++ 在前面先加后使用 ++在后面先使用，在进行++操作 二元：+ - * / % &amp;&amp; || &gt;= &lt;= == === 使用：+ 两边若有一个是字符串会进行字符串拼接操作，- * / % 会进行隐式转换 &amp;&amp; : 与运算 两边都为真才为真 || :或运算 两边有一个为假则为假 27.原型和原型链1.prototype:在JavaScript中，每个函数都有一个prototype属性，这个属性指向函数的原型对象。 123456789101112function Person(age) &#123;this.age = age &#125;Person.prototype.name = &#x27;kavin&#x27;var person1 = new Person()var person2 = new Person()console.log(Person.prototype);// name: &quot;kavin&quot;// constructor: ƒ Person(age)//__proto__: Objectconsole.log(person1.name) //kavinconsole.log(person2.name) //kavin 上述例子中，函数的prototype指向了一个对象，而这个正是调用构造函数时创建的实例原型，也就是person1和person的原型。 原型的概念：每一个JavaScript对象(除null外)创建的时候，就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性。 用一张图表示构造函数和实例原型之间的关系： intanceof 概述：instanceof运算符用来判断一个构造函数的prototype属性所指向的对象是否存在另外一个要检测对象的原型链上 2.__ proto __这是每个对象(除null外)都会有的属性，叫做__ proto __，这个属性会指向该对象的原型。 12345function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // true 关系图： 补充说明： 绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在与Person.prototype中，实际上，它是来自于Object.prototype，与其说是一个属性，不如说是一个getter/setter，当使用obj.__ proto __时，可以理解成返回了Object.getPrototypeOf(obj)。 3.constructor每个原型都一个constructor属性，指向该关联的构造函数。 1234function Person() &#123;&#125;console.log(Person === Person.prototype.constructor); // true 再更新下关系图： 12345678910function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ == Person.prototype) // trueconsole.log(Person.prototype.constructor == Person) // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype) // true 补充说明： 12345function Person() &#123;&#125;var person = new Person();console.log(person.constructor === Person); // true 当获取person.constructor时，其实person中并没有constructor属性，当不能读取到constructor属性时，会从person的原型也就是Person.prototype中读取，正好原型中有该属性，所以: 1console.log(person.constructor === Person.prototype.constructor);// true 4.实例与原型当读取实例的属性，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型，一直找到最顶层为止。 12345678910111213function Person() &#123;&#125;Person.prototype.name = &#x27;Kevin&#x27;;var person = new Person();person.name = &#x27;Daisy&#x27;;console.log(person.name) // Daisydelete person.name;console.log(person.name) // Kevin 在这个例子中，我们给实例对象person添加了name属性，当我们打印person.name的时候，结果自然为Daisy。 但是当我们删除了person的name属性时，读取person.name，从person对象中找不到name属性就会从person的原型也就是person.__ proto __，也就是Person.prototype中查找，幸运的是我们找到了name属性，结果为Kevin。 但是万一还没有找到呢？原型的原型又是什么呢？ 5.原型的原型原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是： 123var obj = new Object();obj.name = &#x27;Kevin&#x27;console.log(obj.name) // Kevin 其实原型对象就是Object构造对象生成的，结合之前所讲，实例的__ proto __指向构造函数的prototype，所以我们更新下关系图： 6.原型链​ 每个对象都可以有一个原型_proto_，这个原型还可以有它自己的原型，以此类推，形成一个原型链。查找特定属性的时候，我们先去这个对象里去找，如果没有的话就去它的原型对象里面去，如果还是没有的话再去向原型对象的原型对象里去寻找…… 这个操作被委托在整个原型链上，这个就是我们说的原型链了。 1console.log(Object.prototype.__proto__ === null) //true undefined与null的区别？ undefined表示就是此处应该有一个值，但是还没有定义。 null表示“没有对象”，即该处不应该有值。 所以Object.prototype.__ proto __的值为null跟Object.prototype没有原型，其实表达了一个意思。 所以查找属性的时候查到Object.prototype 28.js定义类的方法1.工厂方式12345678910111213// 工厂方法function createPerson(name,age)&#123; // 1.原料 var obj = new Object() // 2.加工 obj.name = name obj.age = age obj.sayName = function() &#123; console.log(this.name); &#125; // 3.出厂 return obj&#125; 2.构造函数1234567891011121314function Person(name,age)&#123; // new的时候，实际进行了以下操作: // 1、函数里面会自动完成1原料和3出厂操作 // 2、new调用的函数，会将当前函数中的this指向当前新创建的对象。 // 1.原料 // this = new Object() this.name = name this.age = age this.sayName = function()&#123; console.log(this.name); &#125; // 3.出厂 // return this&#125; 3.组合使用构造函数和原型方法(使用最广)1234567891011function Person(name,age)&#123; this.name = name this.age = age&#125;Person.prototype = &#123; constructor : Person, sayName: function()&#123; console.log(this.name); &#125;&#125; 29.js的继承方式1.原型链继承 子类型的原型为父类型的一个实例对象。 1234567891011121314151617//父类型function Person(name, age) &#123; this.name = name, this.age = age, this.play = [1, 2, 3] this.setName = function () &#123;&#125;&#125;Person.prototype.setAge = function () &#123;&#125;//子类型function Student(price) &#123; this.price = price this.setScore = function () &#123;&#125;&#125;Student.prototype = new Person() // 子类型的原型为父类型的一个实例对象var s1 = new Student(15000)var s2 = new Student(14000)console.log(s1, s2) 特点： 父类新增原型方法/原型属性，子类都能访问到 简单，易于实现 缺点： 无法实现多继承 来自原型对象的所有属性被所有实例共享 创建子类实例时，无法向父类构造函数传参 要想为子类新增属性和方法，必须要在Student.prototype = new Person() 之后执行，不能放到构造器中 2.借用构造函数继承 在子类型构造函数中通过call()调用父类型构造函数 12345678910111213function Person(name, age) &#123; this.name = name, this.age = age, this.setName = function () &#123;&#125;&#125;Person.prototype.setAge = function () &#123;&#125;function Student(name, age, price) &#123; Person.call(this, name, age) // 相当于: this.Person(name, age) /*this.name = name this.age = age*/ this.price = price&#125;var s1 = new Student(&#x27;Tom&#x27;, 20, 15000) 特点： 解决了原型链继承中子类实例共享父类引用属性的问题 创建子类实例时，可以向父类传递参数 可以实现多继承(call多个父类对象) 缺点： 实例并不是父类的实例，只是子类的实例 只能继承父类的实例属性和方法，不能继承原型属性和方法 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 3.原型链+借用构造函数的组合继承 通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数服用。 1234567891011121314151617181920212223function Person(name, age) &#123; this.name = name, this.age = age, this.setAge = function () &#123;&#125;&#125;Person.prototype.setAge = function () &#123; console.log(&quot;111&quot;)&#125;function Student(name, age, price) &#123; Person.call(this, name, age) this.price = price this.setScore = function () &#123;&#125;&#125;Student.prototype = new Person()Student.prototype.constructor = Student //组合继承也是需要修复构造函数指向的Student.prototype.sayHello = function () &#123;&#125;var s1 = new Student(&#x27;Tom&#x27;, 20, 15000)var s2 = new Student(&#x27;Jack&#x27;, 22, 14000)var p1 = new Person(&#x27;Kevin&#x27;,19)console.log(s1)console.log(s1.constructor) //Studentconsole.log(p1.constructor) //Person 优点： 可以继承实例属性/方法，也可以继承原型属性/方法 不存在引用属性共享问题 可传参 函数可复用 缺点： 调用了两次父类构造函数，生成了两份实例 4.ES6中class的继承​ ES6中引入了class关键字，class可以通过extends关键字实现继承，还可以通过static关键字定义类的静态方法,这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 ​ ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。 ​ 需要注意的是，class关键字只是原型的语法糖，JavaScript继承仍然是基于原型实现的。 12345678910111213141516171819202122232425262728class Person &#123; //调用类的构造方法 constructor(name, age) &#123; this.name = name this.age = age &#125; //定义一般的方法 showName() &#123; console.log(&quot;调用父类的方法&quot;) console.log(this.name, this.age); &#125;&#125;let p1 = new Person(&#x27;kobe&#x27;, 39)console.log(p1)//定义一个子类class Student extends Person &#123; constructor(name, age, salary) &#123; super(name, age) //通过super调用父类的构造方法 this.salary = salary &#125; showName() &#123; //在子类自身定义方法 console.log(&quot;调用子类的方法&quot;) console.log(this.name, this.age, this.salary); &#125;&#125;let s1 = new Student(&#x27;wade&#x27;, 38, 1000000000)console.log(s1)s1.showName() 优点： 语法简单易懂,操作更方便 缺点： 并不是所有的浏览器都支持class关键字 前后端交互及综合问题1. 什么是同源策略？如何实现跨域？ 同源策略：同协议、同域名、同端口号 1. 后端可以通过设置CORS帮助解决跨域问题。 响应头中设置 Access-Control-Allow-Origin:* 2. 代理（反向代理）proxy 3. JSONP 跨域【注】标签中的src本身自带跨域的能力。 1. 封装一个函数，这个函数得有一个形参，形参是最后我们下载到的数据 2. 创建script标签，src指向我们要去加载数据 3. 将script标签添加到我们的页面上。【注】要求返回的数据，必须是函数调用的格式。 2. 一个完整的URL地址包含什么 组成部分：协议://主机名:端口号/路径/?查询字符串#锚点 3. HTTP状态码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687881** 信息，服务器收到请求，需要请求者继续执行操作2** 成功，操作被成功接收并处理3** 重定向，需要进一步的操作以完成请求4** 客户端错误，请求包含语法错误或无法完成请求5** 服务器错误，服务器在处理请求的过程中发生了错误100——客户必须继续发出请求101——客户要求服务器根据请求转换HTTP协议版本200——交易成功201——提示知道新文件的URL 202——接受和处理、但处理未完成203——返回信息不确定或不完整204——请求收到，但返回信息为空205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件206——服务器已经完成了部分用户的GET请求300——请求的资源可在多处得到301——删除请求数据302——在其他地址发现了请求数据303——建议客户访问其他URL或访问方式304——客户端已经执行了GET，但文件未变化305——请求的资源必须从服务器指定的地址得到306——前一版本HTTP中使用的代码，现行版本中不再使用307——申明请求的资源临时性删除400——错误请求，如语法错误401——请求授权失败402——保留有效ChargeTo头响应403——请求不允许404——没有发现文件、查询或URl405——用户在Request-Line字段定义的方法不允许406——根据用户发送的Accept拖，请求资源不可访问407——类似401，用户必须首先在代理服务器上得到授权408——客户端没有在用户指定的饿时间内完成请求409——对当前资源状态，请求不能完成410——服务器上不再有此资源且无进一步的参考地址411——服务器拒绝用户定义的Content-Length属性请求412——一个或多个请求头字段在当前请求中错误413——请求的资源大于服务器允许的大小414——请求的资源URL长于服务器允许的长度415——请求资源不支持请求项目格式416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求500——服务器产生内部错误501——服务器不支持请求的函数502——服务器暂时不可用，有时是为了防止发生系统过载503——服务器过载或暂停维修504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长505——服务器不支持或拒绝支请求头中指定的HTTP版本 4. HTTP缓存​ http缓存指的是: 当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求资源”的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源。 ​ 常见的http缓存只能缓存get请求响应的资源，对于其他类型的响应则无能为力，所以后续说的请求缓存都是指GET请求。 http缓存都是从第二次请求开始的。第一次请求资源时，服务器返回资源，并在response header头中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存，命中则返回304，否则服务器会返回新的资源。 1.强制缓存 强制缓存在缓存数据未失效的情况下（即Cache-Control的max-age没有过期或者Expires的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。强制缓存生效时，http状态码为200。这种方式页面的加载速度是最快的，性能也是很好的，但是在这期间，如果服务器端的资源修改了，页面上是拿不到的，因为它不会再向服务器发请求了。这种情况就是我们在开发种经常遇到的，比如你修改了页面上的某个样式，在页面上刷新了但没有生效，因为走的是强缓存，所以Ctrl + F5一顿操作之后就好了。 跟强制缓存相关的header头属性有（Pragma/Cache-Control/Expires）。优先级高低由图上至下。 2、协商缓存 当第一次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期还或者它的属性设置为no-cache时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。如果服务器端的资源没有修改，那么就会返回304状态码，告诉浏览器可以使用缓存中的数据，这样就减少了服务器的数据传输压力。如果数据有更新就会返回200状态码，服务器就会返回更新后的资源并且将缓存信息一起返回。跟协商缓存相关的header头属性有（ETag/If-Not-Match 、Last-Modified/If-Modified-Since）请求头和响应头需要成对出现。 协商缓存的执行流程是这样的：当浏览器第一次向服务器发送请求时，会在响应头中返回协商缓存的头属性：ETag和Last-Modified,其中ETag返回的是一个hash值，Last-Modified返回的是GMT格式的最后修改时间。然后浏览器在第二次发送请求的时候，会在请求头中带上与ETag对应的If-Not-Match，其值就是响应头中返回的ETag的值，Last-Modified对应的If-Modified-Since。服务器在接收到这两个参数后会做比较，如果返回的是304状态码，则说明请求的资源没有修改，浏览器可以直接在缓存中取数据，否则，服务器会直接返回数据。 为什么要使用HTTP缓存 ？ 减少了冗余的数据传输，节省了网费。 缓解了服务器的压力， 大大提高了网站的性能 加快了客户端加载网页的速度 301重定向和302重定向的区别:1.301重定向是永久的重定向，搜索引擎在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址。2.而302重定向只是暂时的重定向，搜索引擎会抓取新的内容而保留旧的地址，因为服务器返回302，所以，搜索搜索引擎认为新的网址是暂时的。 5. TCP协议和UDP协议通信协议是什么？ ​ 我们在公路上需要遵守交通法则，同样数据在网络上进行传输我们也得遵守数据传输的规则。 在数据传输的规则，也就是协议中，最常见的协议就是TCP和UDP协议。其中http协议就是TCP实现的。 TCP协议概念：TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。 账目密码 PC端网络 【注】如果需要传输，就先建立链接，开始传输数据，当数据传输结束，就直接断开链接。如果再要进行传输，重新建立链接。 好处：安全，准确性高，面向连接 坏处：TCP协议比较耗费时间，耗费资源。 服务器建立链接的主要步骤叫做 三次握手 1. 客户端发送一个消息给到服务端 2. 服务端回给客户端一个消息 3. 客户端再回给服务端一个消息 断开链接是基于 TCP/IP 协议的 四次挥手 1. 客户端发送一个我要断开的消息给服务端 2. 服务端接受到以后发送一个消息告诉客户端我已经进入关闭等待状态 3. 服务端再次发送一个消息告诉客户端，这个是我的最后一次消息给你，当我再接受到消息的时候就会关闭 4. 客户端接受到服务端的消息以后，告诉服务器，我已经关闭，这个是给你的最后一个消息 UDP概念：UDP 是User Datagram Protocol的简称， 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。 不连接，直接传 不安全，容易丢。 及时性要求非常高，数据完整度要求不高：及时的语音视频聊天软件。 6. 进程和线程 线程是程序执行的的最小单位，而进程是操作系统分配资源的最小单位。 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线。 进程之间相互独立，但同一进程的各个线程之间共享程序的内存空间。 调度和切换：线程上下文切换比进程上下文切换要快得多。 7.XSS攻击和CSRF攻击XSS全称 Cross Site Scripting ，名为跨站脚本攻击，黑客将恶意脚本代码植入到页面中从而实现盗取用户信息等操作。 常见的攻击情景： ​ 用户A访问安全网站B，然后用户C发现B网站存在XSS漏洞，此时用户C向A发送了一封邮件，里面有包含恶意脚本的URL地址（此URL地址还是网站B的地址，只是路径上有恶意脚本），当用户点击访问时，因为网站B中cookie含有用户的敏感信息，此时用户C就可以利用脚本在受信任的情况下获取用户A的cookie信息，以及进行一些恶意操作。 这种攻击叫做反射性XSS。 ​ 假设网站B是一个博客网站，恶意用户C在存在XSS漏洞的网站B发布了一篇文章，文章中存在一些恶意脚本，例如img标签、script标签等，这篇博客必然会存入数据库中，当其他用户访问该文章时恶意脚本就会执行，然后进行恶意操作。 这种攻击方式叫做持久性XSS，将携带脚本的数据存入数据库，之后又由后台返回。 预防措施： 对输入、输出结果进行过滤和必要的转义。 尽量使用post，使用get方式时对路径长度进行限制。 使用httponly禁止黑客通过脚本获取用户cookie数据，但这样无法完全阻止xss攻击，因为发送http请求并不需要主动获取cookie。 CSRF全称Cross-site request forgery，名为跨站请求伪造，顾名思义就是黑客伪装成用户身份来执行一些非用户自愿的恶意以及非法操作。 常见的攻击场景： ​ 用户A经常访问博客网站B，用户C发现网站B存在CSRF漏洞，想尽了各种办法勾引用户A访问了C写好的危险网站D，而此时用户A的cookie信息还没有失效，危险网站D中有向网站B求请求的非法操作，这样用户在不知情的情况下就被操控了。 ​ 这个时候就会有一个疑问，浏览器本身有同源策略啊，为什么在网站D还可以请求网站B的api，要记住浏览器对img、iframe和script的src是没有同源限制的！所以黑客完全可以利用动态添加这些标签的方法来实现跨站请求。 预防措施： 验证码 tokenid令牌 判断请求的Referer是否正确 CSRF和XSS的区别： CSRF需要登陆后操作，XSS不需要 CSRF是请求页面api来实现非法操作，XSS是向当前页面植入js脚本来修改页面内容。 8.ajax​ 异步执行javascript和数据传输的技术叫做ajax。 ​ 所谓异步，就是向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。创建Ajax的过程： 创建XMLHttpRequest对象（异步调用对象） 1var xhr = new XMLHttpRequest(); 创建新的Http请求（方法、URL、是否异步） 1xhr.open(‘get’,’example.php’,false); 设置响应HTTP请求状态变化的函数。onreadystatechange事件中readyState属性等于4。响应的HTTP状态为200(OK)或者304(Not Modified)。 发送http请求 1xhr.send(data); 获取异步调用返回的数据 注意： 页面初次加载时，尽量在web服务器一次性输出所有相关的数据，只在页面加载完成之后，用户进行操作时采用ajax进行交互。 同步ajax在IE上会产生页面假死的问题。所以建议采用异步ajax。 尽量减少ajax请求次数 ajax安全问题，对于敏感数据在服务器端处理，避免在客户端处理过滤。对于关键业务逻辑代码也必须放在服务器端处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function $ajax(&#123; type = &quot;get&quot;, url, data, success, error &#125;) &#123; type = type.toLowerCase(); var xhr = null; try &#123; xhr = new XMLHttpRequest(); &#125; catch (error) &#123; xhr = ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; //如果请求是get且有数据，拼接url if (type === &quot;get&quot; &amp;&amp; data) &#123; url += &quot;?&quot; + queryString(data); &#125; xhr.open(type, url, true); if (type === &quot;get&quot;) &#123; xhr.send(); &#125; else &#123; //设置编码格式 如果是post请求 xhr.setRequestHeader( &quot;content-type&quot;, &quot;application/x-www-form-urlencoded&quot; ); xhr.send(queryString(data)); &#125; xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; success &amp;&amp; success(xhr.responseText); &#125; else &#123; error &amp;&amp; error(&quot;Error：&quot; + xhr.status); &#125; &#125; &#125;;&#125;function queryString(obj) &#123; var str = &quot;&quot;; if (!obj) &#123; return str; &#125; for (var attr in obj) &#123; str += `$&#123;attr&#125;=$&#123;obj[attr]&#125;&amp;`; &#125; return str.substring(0, str.length - 1);&#125; 9.正向代理和反向代理1. 什么是代理服务器 所谓代理服务器就是位于发起请求的客户端与原始服务器端之间的一台跳板服务器，正向代理可以隐藏客户端，反向代理可以隐藏原始服务器。 2. 正向代理 用户知道目标服务器地址，但由于网络限制等原因，无法直接访问。这时候需要先连接代理服务器，然后再由代理服务器访问目标服务器。 3. 反向代理 反向代理对用户则是不可知的，比如我们访问百度网站，百度的代理服务器对外的域名为 https://www.baidu.com 。具体内部的服务器节点我们不知道，现实中我们通过访问百度的代理服务器后，代理服务器给我们转发请求到他们N多的服务器节点中的一个给我们进行搜索后将结果返回。 10.HTTP和HTTPS的主要区别？ https协议需要到CA申请证书，一般免费证书较少，因而需要一定的费用。 http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443. http的连接很简单，是无状态的；https协议是由ssl/tls+http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 11.get请求和post请求的区别？ Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。 Get传送的数据量较小，这主要是因为受URL长度限制；Post传送的数据量较大，一般被默认为不受限制。 Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。 Get执行效率却比Post方法好。Get是form提交的默认方法。 get只用来从服务器上获取数据，post用来向服务器提交、修改、删除数据。 适用场景： post一般用于表单提交 get一般用于简单的数据查询，严格要求不是那么高的场景 12.类和对象类和对象的区别 定义不同类是现实世界或思维世界中的实体在计算机中的反映，它将数据以及这些数据上的操作封装在一起。对象是具有类类型的变量。类和对象是面向对象编程技术中的最基本的概念。 范畴不同类是一个抽象的概念，它不存在于现实中的时间、空间里，类知识为所有的对象定义了抽象的属性与行为。对象是类的一个具体。它是一个实实在在存在的东西。 状态不同类是一个静态的概念，类本身不携带任何数据。当没有为类创建任何数据时，类本身不存在于内存空间对象是一个动态的概念，每一个对象都存在着有别于其它对象的属于自己的独特的属性和行为，属性可以随着它自己的行为而发生改变。 类和对象的关系 类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。类是用于创建对象的蓝图，它是一个定义包括在特定类型的对象中的方法和变量的软件模板。 13.web前端项目优化常见优化方法从资源请求数量+代码执行效率两个角度来考虑 DOM结构 1.样式表放在头部，防止白屏和闪屏 2.JS脚本放在底部或异步获取，防止阻塞资源加载 3.使用语义化标签，优化精简DOM结构 4.减少DOM操作频率 5.减少重绘与回流 JS脚本 1.优化脚本结构，移除重复的脚本 2.模块就近加载（CMD） 3.按需加载加载组件和路由 4.图片懒加载，列表分页 5.使用节流与防抖减少事件触发频率 6.尽量使用CSS动画代替js动画，开启硬件加速 资源打包上线 1.使用打包构建工具（webpack）清除注释，压缩页面资源，js、css、html、图片、字体等等 2.混淆js代码 3.分离非业务逻辑相关vendor依赖，使用长缓存缓存和CDN分发网络 服务器优化 1.减少Http请求，合并页面资源，js，css单一入口。js特殊可以分为两个文件，一个业务逻辑，一个非业务逻辑 2.把小图标合成雪碧图，不太适用经常更新的移动端开发 3.把小的图片，字体等资源base64化 4.开启GZip压缩，减少资源传输大小 5.使用强缓存和协商缓存，减少资源重复请求 Vue中可以优化的点 1.Vue库dist里面的Runtime-only比Runtime+Compiler小30% 2.Vue的计算属性会根据依赖的data进行缓存 3.keep-alive可以缓存常用组件 4.Vuex中的getter也会根据依赖的state进行缓存 5.v-for中唯一key的使用 6.Vue全局错误处理errorHandle 7.Vue路由懒加载 8.Vue组件动态加载 React中可以优化的点 1.在constructor改变this指向代替箭头函数和render内绑定this，避免函数作为props带来不必要的rerender 2.shouldComponentUpdate，减少不不必要的rerender 3.PureComponent高性能组件只响应引用数据的深拷贝 4.使用唯一key优化list diff 5.合并setState操作，减少虚拟dom对比频率 6.React路由动态加载react-loadable ES61. promise？基础结构：Promise的构造函数接收一个参数 ，是函数，并且传入两个参数: resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数,有三种状态pending(进行中)**、fulfilled(已成功)、rejected(已失败)。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve是将Promise的状态置为fulfilled(已成功)，reject是将Promise的状态置为rejected(已失败)**。 使用：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;);promise.then(function(value)&#123; success&#125;,function(error)&#123; failure&#125;)promise.then(function(value)&#123; success&#125;).catch(function(error)&#123; failure&#125;)//链式加载function getImage(src)&#123; return new Promise(function(res,rej)&#123; let img = new Image() img.onload = function() &#123; res(img) &#125; img.onerror = function() &#123; rej(&quot;这是错误的内容&quot;) &#125; img.src = function() &#123; &#125; &#125;)&#125;getImage(&quot;a.jbg&quot;).then(function(img)&#123; console.log(img) return getImage(&quot;b.jpg&quot;)&#125;).then(function(img)&#123; console.log(img)&#125;)// all// all是三个异步全部完成后，执行的结果，结果是统一返回第一个参数的数组。const p = Promise.all([p1, p2, p3]);// race// race用于同时执行多个异步，如果那个先完成就直接结束，处理这个先完成的。const p = Promise.race([p1, p2, p3]); 封装:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154// 模拟实现Promise// Promise利用三大手段解决回调地狱：// 1. 回调函数延迟绑定// 2. 返回值穿透// 3. 错误冒泡// 定义三种状态const PENDING = &#x27;PENDING&#x27;; // 进行中const FULFILLED = &#x27;FULFILLED&#x27;; // 已成功const REJECTED = &#x27;REJECTED&#x27;; // 已失败class Promise &#123; constructor(exector) &#123; // 初始化状态 this.status = PENDING; // 将成功、失败结果放在this上，便于then、catch访问 this.value = undefined; this.reason = undefined; // 成功态回调函数队列 this.onFulfilledCallbacks = []; // 失败态回调函数队列 this.onRejectedCallbacks = []; const resolve = value =&gt; &#123; // 只有进行中状态才能更改状态 if (this.status === PENDING) &#123; this.status = FULFILLED; this.value = value; // 成功态函数依次执行 this.onFulfilledCallbacks.forEach(fn =&gt; fn(this.value)); &#125; &#125; const reject = reason =&gt; &#123; // 只有进行中状态才能更改状态 if (this.status === PENDING) &#123; this.status = REJECTED; this.reason = reason; // 失败态函数依次执行 this.onRejectedCallbacks.forEach(fn =&gt; fn(this.reason)) &#125; &#125; try &#123; // 立即执行executor // 把内部的resolve和reject传入executor，用户可调用resolve和reject exector(resolve, reject); &#125; catch(e) &#123; // executor执行出错，将错误内容reject抛出去 reject(e); &#125; &#125; then(onFulfilled, onRejected) &#123; onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : value =&gt; value; onRejected = typeof onRejected === &#x27;function&#x27;? onRejected : reason =&gt; &#123; throw new Error(reason instanceof Error ? reason.message : reason) &#125; // 保存this const self = this; return new Promise((resolve, reject) =&gt; &#123; if (self.status === PENDING) &#123; self.onFulfilledCallbacks.push(() =&gt; &#123; // try捕获错误 try &#123; // 模拟微任务 setTimeout(() =&gt; &#123; const result = onFulfilled(self.value); // 分两种情况： // 1. 回调函数返回值是Promise，执行then操作 // 2. 如果不是Promise，调用新Promise的resolve函数 result instanceof Promise ? result.then(resolve, reject) : resolve(result); &#125;) &#125; catch(e) &#123; reject(e); &#125; &#125;); self.onRejectedCallbacks.push(() =&gt; &#123; // 以下同理 try &#123; setTimeout(() =&gt; &#123; const result = onRejected(self.reason); // 不同点：此时是reject result instanceof Promise ? result.then(resolve, reject) : resolve(result); &#125;) &#125; catch(e) &#123; reject(e); &#125; &#125;) &#125; else if (self.status === FULFILLED) &#123; try &#123; setTimeout(() =&gt; &#123; const result = onFulfilled(self.value); result instanceof Promise ? result.then(resolve, reject) : resolve(result); &#125;); &#125; catch(e) &#123; reject(e); &#125; &#125; else if (self.status === REJECTED) &#123; try &#123; setTimeout(() =&gt; &#123; const result = onRejected(self.reason); result instanceof Promise ? result.then(resolve, reject) : resolve(result); &#125;) &#125; catch(e) &#123; reject(e); &#125; &#125; &#125;); &#125; catch(onRejected) &#123; return this.then(null, onRejected); &#125; static resolve(value) &#123; if (value instanceof Promise) &#123; // 如果是Promise实例，直接返回 return value; &#125; else &#123; // 如果不是Promise实例，返回一个新的Promise对象，状态为FULFILLED return new Promise((resolve, reject) =&gt; resolve(value)); &#125; &#125; static reject(reason) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(reason); &#125;) &#125; static all(promiseArr) &#123; const len = promiseArr.length; const values = new Array(len); // 记录已经成功执行的promise个数 let count = 0; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; len; i++) &#123; // Promise.resolve()处理，确保每一个都是promise实例 Promise.resolve(promiseArr[i]).then( val =&gt; &#123; values[i] = val; count++; // 如果全部执行完，返回promise的状态就可以改变了 if (count === len) resolve(values); &#125;, err =&gt; reject(err), ); &#125; &#125;) &#125; static race(promiseArr) &#123; return new Promise((resolve, reject) =&gt; &#123; promiseArr.forEach(p =&gt; &#123; Promise.resolve(p).then( val =&gt; resolve(val), err =&gt; reject(err), ) &#125;) &#125;) &#125;&#125; 2. let const var区别？ var 变量可以提升，let，const变量不可以提升 var 没有暂时性死区，let，const有暂时性死区 var 允许重复声明，let，const不可以重复声明 var 和let可以修改声明的变量，const不可以修改 var 没有块级作用域，let和const有块级作用域在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区” 3. 变量的解构赋值以前我们定义多个变量，可以这样写： 1var x=10,y=20,z=30; 现在我们可以这样写： 12let [x,y,z] = [10,20,30];let [x,[a,b],y] = [10,[15,18],20]; 这并不是在定义数组，而是通过等号两边的结构匹配，进行赋值。 当然，如果你写的不够规范： 12let [x,y] = [10,20,30]; //结果x=10,y=20let [x,[a,b],y] = [10,[5],20]; //结果x=10,a=5,y=20,b=undefined 浏览器并不会报错，依然赋值成功。 甚至可以使用对象来赋值 1var &#123;id,name,age&#125; = &#123;id:43,name:&#x27;yt&#x27;,age:30&#125; 也可以对字符串进行解构赋值，字符串被转换为类数组的对象。 1var [a,b,c,d,e] = &quot;hello&quot; 类似数组的对象都有length属性，因此也可以利用这个属性进行解构赋值。 1var &#123;length:len&#125; = &quot;hello&quot; 解构赋值的用途 交换变量的值 1[a,b] = [b,a]; //排序可能会常用到 函数返回多个值，这个功能比较有颠覆性 12var [r1,r2,r3] = exec();function exec()&#123; return [&quot;结果a&quot;,&quot;结果b&quot;,&quot;结果c&quot; ]; &#125; 函数的参数定义方式，不用再考虑顺序 1function exec(&#123;time, speed, pos&#125;)&#123; &#125; 4. symbol123你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。注意，Symbol函数前不能使用new命令，否则会报错。 5. set和map数据结构123456789101112131415161718192021222324252627282930313233343536373839404142434445Set集合是默认去重复的，但前提是两个添加的元素严格相等 所以5和&quot;5&quot;不相等，两个new出来的字符串不相等。关于遍历的方法 由于Set集合本质上还是一个map，因此会有以下几种奇怪的遍历方法var imgs = new Set([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c’])//根据KEY遍历 for(let item of imgs.keys())&#123; console.log(item); &#125;//a //b //c//根据VALUE遍历 for(let item of imgs.values())&#123; console.log(item); &#125; //a//b //c//根据KEY-VALUE遍历 for(let item of imgs.entries())&#123; console.log(item); &#125; //[&#x27;a&#x27;,&#x27;a’] //[&#x27;b&#x27;,&#x27;b’]//[‘c’,’c’]//普通for...of循环(for...of跟for-in的区别很明显，就是直接取值，而不再取下标了) for(let item of imgs)&#123; console.log(item); &#125; //a //b //cSET集合没有提供下标方式的访问，因此只能使用for来遍历。下面展示了一种极为精巧的数组去重的方法 var newarr = [...new Set(array)];let map = new Map();map.set(&quot;S230&quot;, &quot;张三&quot;);map.set(&quot;S231&quot;, &quot;李四&quot;);map.set(&quot;S232&quot;, &quot;王五”);//获取某一个元素 map.get(&quot;s232&quot;); //王五//循环遍历，配合解构赋值 for(let [key,value] of map)&#123; console.log(key,value);&#125; 6. Iterator和for…of循环7. async和await123实际上使用promise和Generator封装的。1.await后面接一个会return new promise的函数并执行它2.await只能放在async函数里 8. class123456789101112131415基本用法:class Person&#123; constructor(name,sex)&#123; this.name = name; this.sex = sex; &#125;&#125;继承:class Student extends Person&#123; constructor(name,sex,job)&#123; // super()和super(name,sex)的对比？ // super()继承的是无参构造方法constructor() // super(name,sex)继承的是有参构造方法constructor(name.sex) super(name,sex)//继承父元素的属性 this.job = job &#125;&#125; 9. Generator在函数声明的时候，前面加*号，生成函数迭代器如果我们去调用这个函数，那么返回一个函数迭代器对象Generator对象 123456function *show()&#123; console.log(&quot;一堆代码&quot;); return &quot;hello world&quot;;&#125;var res = show();console.log(res); Generator对象 有一个叫next的方法，这个方法，是专门用于函数调用的。作用： 是将函数的多个操作，分步执行，而且可以记录函数调用的状态，下次调用，从上一次的状态开始执行。 123456789101112131415161718192021function *loop()&#123; console.log(&quot;执行代码1&quot;); //yield：定义不同的内部状态 yield &quot;结果1&quot;; console.log(&quot;执行代码2&quot;); yield &quot;结果2&quot;; console.log(&quot;执行代码3&quot;); yield &quot;结果3&quot;; console.log(&quot;执行代码4&quot;); return &quot;结果4&quot;;&#125;var res = loop();console.log(res);var obj1 = res.next();console.log(obj1);var obj2 = res.next();console.log(obj2);var obj3 = res.next();console.log(obj3);var obj4 = res.next();console.log(obj4); //执行结果loop {}执行代码1{value: “结果1”, done: false}执行代码2{value: “结果2”, done: false}执行代码3{value: “结果3”, done: false}执行代码4{value: “结果4”, done: true} 10. proxyroxy是专门为对象设置访问代理器的，通过Proxy可以轻松监视到对象的读写过程，相比于defineProperty，Proxy他的功能要更为强大甚至使用起来也更为方便。这里我们定义一个person对象，我们通过new Proxy的方式来去为我们的person来创建一个代理对象。 Proxy构造函数的第一个参数就是我们需要代理的对象，这里是person，第二个参数也是一个对象，我们可以把这个对象称之为代理的处理对象，这个对象中可以通过get方法来去监视属性的访问，通过set方法来去介绍对象当中设置属性这样的一个过程。 12345678910const person &#x3D; &#123; name: &#39;yd&#39;, age: 18&#125;const personProxy &#x3D; new Proxy( person, &#123; get() &#123;&#125;, set() &#123;&#125; &#125;) 先来看get方法，这个方法最简单可以接收两个参数，第一个就是所代理的目标对象，第二个就是外部所访问的这个属性的属性名。这个方法的返回值将会作为外部去访问这个属性得到的结果。 123456&#123; get(target, property) &#123; console.log(target, property); return property in target ? target[property] : undefined; &#125;&#125; 再来看下set方法，这个方法默认接收三个参数, 分别是代理目标对象，以及我们要写入的属性名称还有最后我们要写入的属性值。我们可以做一些校验，比如说如果设置的是age，他的值就必须是整数，否则就抛错。 1234567891011&#123; set(target, property, value) &#123; console.log(target, property, value); if (property &#x3D;&#x3D;&#x3D; &#39;age&#39;) &#123; if (!Number.isInteger(value)) &#123; throw new TypeError(&#96;&#96;$&#123;value&#125; must be a integer); &#125; &#125; target[property] &#x3D; value; &#125;&#125; 相比于Object.defineProperty, Proxy到底有哪些优势。 首先最明显的优势就是在于Proxy要更为强大一些，那这个强大具体体现在Object.defineProperty只能监听到对象属性的读取或者是写入，而Proxy除读写外还可以监听对象中属性的删除，对对象当中方法的调用等等。 第二点优势就是对于数组对象进行监视，通常我们想要监视数组的变化，基本要依靠重写数组方法，这也是Vue的实现方式，proxy可以直接监视数组的变化。以往我们想要通过Object.defineProperty去监视数组的操作最常见的方式是重写数组的操作方法，这也是Vue.js中所使用的方式，大体的方式就是通过自定义的方法去覆盖掉数组原型对象上的push，shift之类的方法，以此来劫持对应的方法调用的过程。 11. 数组的扩展1234展开运算符：...Array.from()：用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。find()：数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。findIndex()：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 12. 对象的扩展12Object.assign():用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。第一个参数是目标对象，后面的参数都是源对象。注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 13. 箭头函数和function的区别？ 箭头函数是匿名函数，不能作为构造函数，不能使用new 箭头函数内没有arguments，可以用展开运算符…解决，reset参数。 箭头函数的this，始终指向父级上下文（箭头函数的this取决于定义位置父级的上下文，跟使用位置没关系，普通函数this指向调用的那个对象） 箭头函数不能通过call() 、 apply() 、bind()方法直接修改它的this指向。(call、aaply、bind会默认忽略第一个参数，但是可以正常传参) 箭头函数没有原型属性 14. import export123456ES6之前模块引入主要是CommonJS和AMD两种。CommonJS和ES6模块引入的区别：1.首先，CommonJS导出值是浅拷贝，一单输出某个值，模块内部的变化影响不到这个值。而ES6导出采用实时绑定的方式，是将其内存地址导出，导入是动态地加载模块取值，并且变量，并且变量总是绑定其所在的模块，不能重新赋值。2.ES6模块化导入是异步导入，CommonJS导入是同步导入。这跟ES6模块通常用于web端，而CommonJS用于服务器端有关。3.CommonJS导入支持动态导入require(`$&#123;path&#125;/xx.js`)，ES6模块化导入不支持。目前已有草案。4.ES6模块化会编译成require/exports来执行的。 15. 字符串的扩展模板字符串, 使用反引号表示，使用${变量|函数}嵌入代码node.innerHTML = 你好，我的名字叫$&#123;username&#125; 接下来是我的自我介绍：${introduce()}` vue1. vue内置指令牵扯的面试题 v-show和v-if的区别？ 123451.v-if 和v-show 都是表示控制dom元素显示隐藏的2.v-if 有更高的切换开销，v-show 有更高的初始渲染开销3.如果需要频繁的使用,则使用 v-show 较好，如果在运行时条件很少改变，则使用 v-if 较好4.v-show 是通过改变样式来改变dom的元素的显示隐藏的5.v-if是根据表达式值的真假进行渲染和移出元素的。 v-for的理解？为什么加key？ 123456789101112理解：1.v-for 用来遍历数据的2.v-for 通常使用 key 属性给每项元素添加识别码3.V-for可以通过添加 index 给每项元素添加index索引为什么使用key：1.vue中列表循环需加:key=&quot;唯一标识&quot; 唯一标识尽量是item里面id等，因为vue组件高度复用，增加Key可以标识组件的唯一性，为了更好地区别各个组件，key的作用主要是为了高效的更新虚拟DOM。2.key主要用来做dom diff算法用的，diff算法是同级比较，比较当前标签上的key还有它当前的标签名，如果key和标签名都一样时只是做了一个移动的操作，不会重新创建元素和删除元素。3.没有key的时候默认使用的是“就地复用”策略。如果数据项的顺序被改变，Vue不是移动Dom元素来匹配数据项的改变，而是简单复用原来位置的每个元素。如果删除第一个元素，在进行比较时发现标签一样值不一样时，就会复用之前的位置，将新值直接放到该位置，以此类推，最后多出一个就会把最后一个删除掉。4.尽量不要使用索引值index作key值，一定要用唯一标识的值，如id等。因为若用数组索引index为key，当向数组中指定位置插入一个新元素后，因为这时候会重新更新index索引，对应着后面的虚拟DOM的key值全部更新了，这个时候还是会做不必要的更新，就像没有加key一样，因此index虽然能够解决key不冲突的问题，但是并不能解决复用的情况。如果是静态数据，用索引号index做key值是没有问题的。5.标签名一样，key一样这时候就会就地复用，如果标签名不一样，key一样不会复用。6.key 帮助 React、vue 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。7.key 必须是唯一的。通常，我们使用数据中的id来作为元素的key v-if和v-for一起使用问题详解 12345//v-for具有比v-if更高的优先级，这意味着v-if将分别重复运行于每个v-for循环中，所以，不推荐v-if和v-for使用。//当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。当你想为仅有的一些项渲染节点时，这种优先级的机制会十分有用，如下：&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt;&#123;&#123; todo &#125;&#125;&lt;/li&gt; v-bind 12动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。:class v-on 123绑定事件监听器。v-on:click=&quot;clickMe()&quot;@click=&quot;clickMe()&quot; v-model 12在表单控件或者组件上创建双向绑定。底层实现原理：绑定的@input事件 v-pre：跳过这个元素和它的子元素的编译过程。一些静态的内容不需要编辑加这个指令可以加快编辑 v-once：只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。 v-text：更新元素的 textContent。如果要更新部分的 textContent，需要使用 &#123;&#123; Mustache &#125;&#125; 插值。 v-html：更新元素的 innerHTML，引起xss攻击 2. 什么是虚拟dom？ Virual DOM是用JS对象记录一个dom节点的副本，当dom发生更改时候，先用 虚拟dom进行diff，算出最小差异，然后再修改真实dom。 ​ 当用传统的方式操作DOM的时候，浏览器会从构建DOM树开始从头到尾执行一遍流程，效率很低。而虚拟DOM是用javascript对象表示的，而操作javascript是很简便高效的。虚拟DOM和真正的DOM有一层映射关系，很多需要操作DOM的地方都会去操作虚拟DOM，最后统一一次更新DOM。因而可以提高性能。 虚拟DOM的缺点： 代码更多，体积更大 内存占用增大 小量的单一的dom修改使用虚拟dom成本反而更高，不如直接修改真实dom快 3. 什么是diff算法？ diff算法就是用JavaScript来表示一个dom树的结构， 然后用这个dom去构建一个真实的dom 插入到文档中， 当状态变更的时候 重新构造一个dom树 比较新旧dom树 记录两个dom树的差异 并且通知视图开始更新 4. vue的生命周期函数？ 初始化 (create)— 组件挂载(mount)—–组件更新 (update)— 销毁(destroy) beforeCreate 初始化界面前 : 在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问 created 初始化界面后 : 在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数,也就是不会更新视图，SSR可以放这里。 beforeMount 挂载前 ：完成模板编译，虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated mounted 挂载完成 ： 将编译好的模板挂载到页面 (虚拟DOM挂载) ，可以在这进行异步请求以及DOM节点的访问，在vue用$ref操作 beforeUpdate 更新数据前 ： 组件数据更新之前调用，数据都是新的,页面上数据都是旧的 组件即将更新,准备渲染页面 , 可以在当前阶段进行更改数据，不会造成重渲染 updated 组件更新后 ： render重新渲染 , 此时数据和界面都是新的 ,要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新 beforeDestroy 组件卸载前 : 实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器 destroyed 组件卸载后 ： 组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。 activited keep-alive 专属 , 组件被激活时调用 deactivated keep-alive 专属 , 组件被销毁时调用 5. watch和computed区别 1234567891011121314151617计算属性computed:1.支持缓存，只有依赖数据发生改变，才会重新计算2.不支持异步，当computed内有异步操作时无效，无法监听到数据的变化3.computed属性值会默认走缓存，计算属性是基于它们的响应式依赖进行的缓存的，也就是基于data声明过或者父组件传递的props中的数据通过计算得到的值4.如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed5.如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据发生变化时，调用set方法watch：1.不支持缓存，数据变化，直接会触发相应的操作；2.watch支持异步3.监听的函数接受两个参数，第一个参数是最新的值；第二个参数是输入之前的值；4.当一个属性发生变化时，需要执行对应的操作；一对多5.监听数据必须是data中声明过的或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数： immediate：组件加载时立即触发回调函数的执行 deep：深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组的变异，只有响应式的方式触发才会被监听到。 handler：监听的数据发生变化的时候时发生具体的变化。 监听的对象也可以写成字符串的形式 当需要在数据变化时执行异步操作或者开销较大的操作时，这个方式是最有用的。这是和computed最大的区别。 6. vue的全局api 1234567891011121314151617181920212223242526271.Vue.extend：用于创建一个子类的Vue，用$mount挂载。2.Vue.nextTick([callback,context])：在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。3.Vue.set(target,key,value)：普通的情况下对Vue实例里面的数据进行更改，数据改掉了，但是呈现在页面的视图并没有发生变化，所以借用该方法视图也会跟着刷新。4.Vue.delete(target,key)用法和原理与set添加元素是一样的道理5.Vue.directive(id,[definition])指令函数，定义了以下几个钩子，每个钩子都有参数el，指的是绑定的元素。作用：操作DOMbind：只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。inserted：被绑定元素插入节点时调用(父节点存在即可调用，不必存在document中)update：被绑定的元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可忽略不必要的模板更新。componentUpdated：被绑定元素所在模板完成一次更新周期时调用。unbind：只调用一次，指令与元素解绑时调用。参数： el：指令所绑定的元素，可以用来直接操作DOM。 binding：一个对象，包含以下属性： name：指令名，不包含v-前缀。 value：指令的绑定值，例如：v-my-directive=&quot;1+1&quot;中，绑定值为2 oldValue：指令绑定的前一个值，仅在update和componentUpdated钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如：v-my-directive=&quot;1+1&quot;中，表达式为&quot;1+1&quot; arg：传给指令的参数，可选。例如：v-my-dircective:foo，参数为&quot;foo&quot;。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar中，修饰符对象为&#123;foo:true,bar:true&#125;。 vnode：Vue编译生成的虚拟节点。 oldVnode：上一个虚拟节点，仅在update和componentUpdated钩子中可用。6.Vue.filter(id,[definition])：注册或获取全局过滤器，主要用于在实例里面的数据不改变的情况下，在页面对渲染进dom的数据进行过滤处理。7.Vue.component(id,[definition])：注册或获取全局组件。注册还会自动使用给定的 id 设置组件的名称8.Vue.version()用于获取当前Vue的版本号9.Vue.use()用于安装Vue插件10.Vue.mixin()：用来更高效的实现组件内容的复用。 7. 优化vue首屏加载过慢，减少白屏时间？1.加速或减少HTTP请求损耗 使用CDN加载公用库，使用强缓存和协商缓存，使用域名收敛，小图片使用Base64代替，使用Get请求代替Post请求，设置 Access-Control-Max-Age 减少预检请求，页面内跳转其他域名或请求其他域名的资源时使用浏览器prefetch预解析等； 2. 延迟加载 非重要的库、非首屏图片延迟加载，SPA的组件懒加载等； 3.减少请求内容的体积 开启服务器Gzip压缩，JS、CSS文件压缩合并，减少cookies大小，SSR直接输出渲染后的HTML等； 4.浏览器渲染原理 优化关键渲染路径，尽可能减少阻塞渲染的JS、CSS； 5.浏览器渲染原理 白屏使用加载进度条、菊花图、骨架屏代替等； 8. 关于vue？ 123456789101112vue是由饿了么ued团队维护并开发渐进式js框架。vue是一个MVVM的框架。vue的核心？数据驱动和组件化。如何使用vue去构建项目？使用@vue/cli脚手架工具构建、也可以直接引入vue.js进行项目的构建。vue生命函数详解？组件创建时（creating）模板渲染时（mounting）数据更新时（updating）组件卸载时（destroying） 9. vue组件封装过程（怎样封装一个vue组件？）为什么要封装组件？主要目的是为了解耦。通用组件必须具备高性能，低耦合的特性（往往我们还会在通用组件留一个插槽）。 为什么自定义组件data必须是一个函数？因为js本身的特性带来的，如果 data 是一个对象，那么由于对象本身属于引用类型，当我们修改其中的一个属性时，会影响到所有Vue实例的数据。如果将 data 作为一个函数返回一个对象，那么每一个实例的 data 属性都是独立的，不会相互影响了。 vue组件的功能？1）能够把页面抽象成多个相对独立的模块2）实现代码重用，提高开发效率和代码质量，使得代码易于维护 Vue组件封装过程？首先，使用Vue.extend()创建一个组件然后，使用Vue.component()方法注册组件接着，如果子组件需要数据，可以在props中接受定义最后，子组件修改好数据之后，想把数据传递给父组件，可以使用emit()方法 创建组件模板 方法一 1234var com = Vue.extend(&#123; //通过template属性 指定组件要展示的html结构 template:&#x27;&lt;h3&gt;这是使用Vue.extend搭建的全局组件&lt;/h3&gt;&#x27; &#125;) 方法二：使用对象创建模板 123&#123; template:&#x27;&lt;h3&gt;这是使用Vue.extend搭建的全局组件-com3&lt;/h3&gt;&#x27; &#125; 方法三：使用template标签（写在受控区域外面）创建模板，通过id建立联系 1234&lt;template id=&quot;tmpl&quot;&gt; 写在受控区域外面 ......&lt;/template&gt; &#123; template:&#x27;#tmpl&#x27; &#125; 10. axios是什么？怎么使用？描述使用它实现登录功能的流程？axios是基于promise一个http库，用于浏览器和nodejs中，主要用于向后台发起请求的，还有就是在请求中做更多的控制。 支持promise 提供了一些并发的方法 提供拦截器 浏览器支持防止CSRF（跨站请求伪造） axios fetch ajax（jquery）的区别？前两者都是支持promise的语法，后者主要还是利用callback的方式fetch本质上脱离了xhr，是新的语法（默认不传cookie，不能像xhr那样可以去监听请求的进度） 1234567891011121314151617181920212223242526272829303132// http request 拦截器axios.interceptors.request.use( config =&gt; &#123; if (store.state.token) &#123; // 判断是否存在token，如果存在的话，则每个http header都加上token config.headers.Authorization = `token $&#123;store.state.token&#125;`; &#125; return config; &#125;, err =&gt; &#123; return Promise.reject(err); &#125;); // http response 拦截器axios.interceptors.response.use( response =&gt; &#123; return response; &#125;, error =&gt; &#123; if (error.response) &#123; switch (error.response.status) &#123; case 401: // 返回 401 清除token信息并跳转到登录页面 store.commit(types.LOGOUT); router.replace(&#123; path: &#x27;login&#x27;, query: &#123;redirect: router.currentRoute.fullPath&#125; &#125;) &#125; &#125; return Promise.reject(error.response.data) // 返回接口返回的错误信息 &#125;); 在前后端完全分离的情况下，Vue项目中实现token验证大致思路如下： 第一次登录的时候，前端调后端的登陆接口，发送用户名和密码 后端收到请求，验证用户名和密码，验证成功，就给前端返回一个token 前端拿到token，将token存储到localStorage和vuex中，并跳转路由页面 前端每次跳转路由，就判断 localStroage 中有无 token ，没有就跳转到登录页面，有则跳转到对应路由页面 每次调后端接口，都要在请求头中加token 后端判断请求头中有无token，有token，就拿到token并验证token，验证成功就返回数据，验证失败（例如：token过期）就返回401，请求头中没有token也返回401 如果前端拿到状态码为401，就清除token信息并跳转到登录页面 注册： 前端：填写手机号、登录密码、验证码 前端：点击获取激活码，验证手机号是否正确(正则) 后端：验证手机号是否已经注册验证验证码是否正确根据手机号发送对应的激活码(第三方平台：阿里云、腾讯云、华为云、网易云、容联云、榛子云)将激活码和创建时间进行存储，然后等待前端输入验证 前端：填写激活码，勾选协议，进行注册 后端：验证激活码，激活码存在且未超时 则继续下方业务 未通过激活码，应该提示错误信息再次验证手机号是否已经注册 未注册则进行注册业务实现，否则提示错误信息 11. vuex是什么？怎么使用？哪种场景会使用到它。是什么？​ vuex是一个专门为vue构建的状态集管理，主要是为了解决组件间状态共享的问题，强调的是集中式管理，主要是便于维护，便于解耦，所以不是所有的项目都适合使用vuex。如果不是构建大型项目，使用vuex，反而会使你的项目繁琐多余。 怎么使用？vuex的核心state：存放状态mutations：操作state数据的方法的集合，比如对该数据的修改、增加、删除等等。默认的形参： 1、state是当前VueX对象中的state 2、payload是该方法在被调用时传递参数使用的getters：可以对state中的成员加工后传递给外界。两个默认参数： 1、state 当前VueX对象中的状态对象 2、getters 当前getters对象，用于将getters下的其他getter拿来用actions：由于直接在mutation方法中进行异步操作，将会引起数据失效。所以提供了Actions来专门进行异步操作，最终提交mutation方法。参数： context 上下文(相当于箭头函数中的this)对象 payload 挂载参数modules：当项目庞大，状态非常多时，可以采用模块化管理模式。Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割。 vue持久化​ vuex可以进行全局的状态管理，但刷新后数据会消失，这是我们不愿意看到的。怎么解决呢，我们可以结合本地存储做到数据状态持久化，也可以通过插件vuex-persistedstate。 12. 导航钩子有哪些？它们有哪些参数导航钩子—-路由的生命周期函数(vue-router)全局和局部全局的钩子函数 beforeEach：在路由切换开始时调用 afterEach：在路由切换离开时调用 局部到单个路由 beforeEnter：在路由切换开始时调用 单个组件的钩子函数beforeRouterEnter,beforeRouterUpdate,beforeRouterLeave参数：to：即将进入的路由对象from：当前导航要离开的路由对象next：是一个函数调用resolve执行下一步。 13. v-model是什么？Vue中标签怎么绑定事件？vue中利用v-model来进行表单数据的双向绑定。原理：v-bind绑定了一个value的属性，利用v-on把当前的元素绑定到一个事件上。 14. swiper插件从后台获取数据没问题，css代码也没问题，当时图片不动，应该怎么解决？主要原因:swiper提前初始化了，而这个时候数据还没有完全出来。 解决方法：主要有两个方向，一个从swiper入手，一个从vue入手。vue中专门给你提供了一个方法nextTick()用于解决dom先后执行顺序问题。父元素发生变化时，重新实例化。observe:trueobserveParents:true 15. 路由懒加载懒加载也叫延迟加载，即在需要的时候加载。 const Foo = () =&gt; Promise.resolve({组件定义对象}) component:()=&gt;import(/webpack chunk name/“路径”) 当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。 结合 Vue 的异步组件和 Webpack 的代码分割功能，轻松实现路由组件的懒加载。 首先，可以将异步组件定义为返回一个 Promise 的工厂函数 (该函数返回的 Promise 应该 resolve 组件本身)： 1const Foo &#x3D; () &#x3D;&gt; Promise.resolve(&#123; &#x2F; 组件定义对象 &#x2F; &#125;) 第二，在 Webpack 2 中，我们可以使用动态 import语法来定义代码分块点 (split point)： 1import(&#39;.&#x2F;Foo.vue&#39;) &#x2F;&#x2F; 返回 Promise 结合这两者，这就是如何定义一个能够被 Webpack 自动代码分割的异步组件。 1const Foo &#x3D; () &#x3D;&gt; import(&#39;.&#x2F;Foo.vue&#39;) 16. Vue-loader什么是vue-loader？基于webpack的一种加载器，能把.vue组件转化成JavaScript模块。 为什么我们要转译这个vue组件？可以动态的渲染一些数据；对template、style、script标签优化，script中可以直接使用es6，也默认可以使用sass，并且还给你提供了作用域的选择；另外开发阶段，还给你提供热加载。 17. 用过插槽吗？用的是具名插槽还是匿名插槽？vue中的插槽slot就是一个占位的。在vue中插槽包括三种，一种是默认插槽（匿名）一种是具名插槽，还有一种是作用域插槽。匿名插槽就是没有名字的，只要默认的，都填到这里。具名插槽指的是具有名字的。作用域插槽:slot-scope获取到插槽中的属性 18. 说一说你对vue虚拟DOM的理解？什么是虚拟dom？以js对象的形式去添加dom元素。本质上是优化了diff算法。采用了新旧dom的对比，获取差异的dom，一次性更新到真实的dom中。虚拟dom本身也有自己的缺陷，它更适合批量修改dom。尽量不要跨层级修改dom。设置key，可以最大的利用节点。 虚拟DOM的缺点： 代码更多，体积更大 内存占用增大 小量的单一的dom修改使用虚拟dom成本反而更高，不如直接修改真实dom快 19. 如何理解Vue的MVVM模式？mvvm和mvc之间的区别？ mvc model view controller 特点： View传送指令到Controller。 Controller完成业务逻辑后，要求Model改变状态。 Model将新的数据发送到View，用户得到反馈。 所有通信都是单向的 mvvm 也分为三层 model view viewModel 特点： 各部分之间的通信，都是双向的。 采用双向绑定：View的变动，自动反映在ViewModel，反之亦然。 数据驱动​ 就是当数据发生变化的时候，用户界面发生相应的变化，开发者不需要手动的修改dom。 如何实现？​ 首先，vuejs在实例化的过程中，会对遍历传给实例化对象选项中的data选项，遍历其所有属性并使用Object.defineProperty()把这些属性全部转换为getter/setter。 ​ 同时每一个实例对象都有一个watcher实例对象，它会在模板编译的过程中，用getter去访问data的属性，watcher此时就会把用到的data属性记为依赖，这样就建立了视图与数据之间的联系。当之后我们渲染视图的数据依赖发生改变（即数据的setter被调用）的时候，watcher会对比前后两个数值是否发生变化，然后确定是否通知视图进行重新渲染。 20、vue中的keep-alive的作用？什么是keep-alive？当在这些组件之间切换的时候，想保持这些组件的状态，以避免反复渲染导致的性能问题。它提供了include与exclude两个属性，允许组件有条件的缓存。include:缓存白名单，keep-alive会缓存被选中的组件exclude：缓存黑名单，不会缓存被选中的组件。 实现的原理是什么？就是在create时候，将需要缓存的vnode节点，放到cache中，在render的时候，根据name在进行取出。 怎么使用它？1234567891011121314&#123; path: &#x27;/&#x27;, name: &#x27;index&#x27;, meta:&#123; keepAlive:true //该字段表明页面需要缓存 &#125;, component: resolve=&gt;require([&quot;@/page/index&quot;],resolve)&#125;&lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;keep-alive include=&quot;a,b&quot;&gt; &lt;component :is=&quot;a&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt; 21. router-link和router-view12345&lt;router-link to=&#x27;/home&#x27;&gt;&lt;/router-link&gt;//vue 内置标签 在渲染时渲染成a标签在点击的情况路由中的页面在&lt;router-view&gt;标签中渲染to属性可以跳转页面tag=&quot;button&quot; 属性可以渲染成想要的原生标签&lt;router-view&gt;&lt;/router-view&gt;写在组件想要渲染的地方,等组件跳转过来就渲染 22. vue实现数据双向绑定原理？vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 怎样实现数据双向绑定原理？ 首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。 接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。因此接下去我们执行以下3个步骤，实现数据的双向绑定： 实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。 实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。 实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。 23. 解释单向数据流和双向数据绑定？ 单向数据流 数据流是单向的。数据流动方向可以跟踪，流动单一，追查问题的时候可以更快捷。缺点就是写起来不太方便。 双向数据绑定 要是UI发生变更就必须创建各种action维护对应的state双向数据绑定：数据之间是相通的，将数据变更的操作隐藏在框架内部。 优点是在表单交互较多的场景下，会简化大量与业务无关的代码。 缺点就是无法追踪局部状态的变化，增加了出错时debug难度。 24. 组件通信 父组件向子组件通信 子组件通过props属性，绑定父组件数据，实现双方通信。 ref与$parent/$children provide和inject $attrs、$listeners 子组件向父组件通信 将父组件的事件在子组件中通过$emit触发 非父子组件、兄弟组件之间的数据传递 123456789101112// 事件总线/*新建一个Vue实例作为中央事件总线*/let bus = new Vue();/*监听事件，发送数据*/event.$on(&#x27;eventName&#x27;, (val) =&gt; &#123; //......do something&#125;);/*触发事件，接收数据*/event.$emit(&#x27;eventName&#x27;, &#x27;this is a message.&#x27;) vuex数据管理 25. vue等单页面应用的优缺点 单页面应用(SPA): 优点： 良好的交互体验 良好的前后端工作分离模式 减轻服务器压力 缺点 SEO难度较高 前进、后退管理 初次加载耗时多 26. nextTick​ 在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。 Vue.nextTick() 全局方法 this.$nextTick() 局部方法 27. 自定义指令？1234567891011全局定义：Vue.directive(名称, 对象|函数)局部定义：new Vue(&#123; directives: &#123; 名称: 对象|函数 &#125;&#125;) 28. vue怎么实现强制刷新组件？ v-if 12345678910111213141516171819//当v-if的值发生变化时，组件都会被重新渲染一遍。因此，利用v-if指令的特性，可以达到强制&lt;comp v-if=&quot;update&quot;&gt;&lt;/comp&gt;&lt;button @click=&quot;reload()&quot;&gt;刷新comp组件&lt;/button&gt;data() &#123; return &#123; update: true &#125; &#125;, methods: &#123; reload() &#123; // 移除组件 this.update = false // 在组件移除后，重新渲染组件 // this.$nextTick可实现在DOM 状态更新后，执行传入的方法。 this.$nextTick(() =&gt; &#123; this.update = true &#125;) &#125; &#125; this.$forceUpdate 123456&lt;button @click=&quot;reload()&quot;&gt;刷新当前组件&lt;/button&gt;methods: &#123; reload() &#123; this.$forceUpdate() &#125;&#125; 29. vue能监听到数组变化的方法有哪些？为什么这些方法能监听到呢？1push、pop、shift、unshift、splice、sort、reverse 30. hash模式和history模式的区别 hash模式较丑，history模式较优雅 pushState设置的新URL可以是与当前URL同源的任意URL；而hash只可修改#后面的部分，故只可设置与当前同文档的URL pushState设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来不一样才会触发记录添加到栈中 pushState通过stateObject可以添加任意类型的数据到记录中；而hash只可添加短字符串 pushState可额外设置title属性供后续使用 hash兼容IE8以上，history兼容IE10以上 hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 http://www.abc.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。 history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http://www.abc.com/book/id 如果后端缺少对 /book/id 的路由处理，将返回 404 错误。 31. vue项目优化 1. 代码层面的优化 v-if 和 v-show 区分使用场景 computed 和 watch 区分使用场景 v-for 遍历必须为 item 添加 key，且避免同时使用 v-if 长列表性能优化 事件的销毁 图片资源懒加载 路由懒加载 第三方插件的按需引入 优化无限列表性能 服务端渲染 SSR or 预渲染 2. Webpack 层面的优化 Webpack 对图片进行压缩 减少 ES6 转为 ES5 的冗余代码 提取公共代码 模板预编译 提取组件的 CSS 优化 SourceMap 构建结果输出分析 Vue 项目的编译优化 3. 基础的 Web 技术的优化 开启 gzip 压缩 浏览器缓存 CDN 的使用 使用 Chrome Performance 查找性能瓶颈 32. vue路由跳转方式有哪几种？ 1.router-link 1234567891011121314151617不带参数&lt;router-link :to=&quot;&#123;name:&#x27;home&#x27;&#125;&quot;&gt; &lt;router-link :to=&quot;&#123;path:&#x27;/home&#x27;&#125;&quot;&gt; //name,path都行, 建议用name // 注意：router-link中链接如果是&#x27;/&#x27;开始就是从根路由开始，如果开始不带&#x27;/&#x27;，则从当前路由开始。 带参数&lt;router-link :to=&quot;&#123;name:&#x27;home&#x27;, params: &#123;id:1&#125;&#125;&quot;&gt; // params传参数 (类似post)// 路由配置 path: &quot;/home/:id&quot; 或者 path: &quot;/home:id&quot; // 不配置path ,第一次可请求,刷新页面id会消失// 配置path,刷新页面id会保留 // html 取参 $route.params.id// script 取参 this.$route.params.id &lt;router-link :to=&quot;&#123;name:&#x27;home&#x27;, query: &#123;id:1&#125;&#125;&quot;&gt; // query传参数 (类似get,url后面会显示参数)// 路由可不配置// html 取参 $route.query.id// script 取参 this.$route.query.id 2.this.$router.push() (函数里面调用) 123456789不带参数 this.$router.push(&#x27;/home&#x27;)this.$router.push(&#123;name:&#x27;home&#x27;&#125;)this.$router.push(&#123;path:&#x27;/home&#x27;&#125;)query传参 this.$router.push(&#123;name:&#x27;home&#x27;,query: &#123;id:&#x27;1&#x27;&#125;&#125;)this.$router.push(&#123;path:&#x27;/home&#x27;,query: &#123;id:&#x27;1&#x27;&#125;&#125;) // html 取参 $route.query.id// script 取参 this.$route.query.id 2.1 params传参 123456this.$router.push(&#123;name:&#x27;home&#x27;,params: &#123;id:&#x27;1&#x27;&#125;&#125;) // 只能用 name// 路由配置 path: &quot;/home/:id&quot; 或者 path: &quot;/home:id&quot; ,// 不配置path ,第一次可请求,刷新页面id会消失// 配置path,刷新页面id会保留// html 取参 $route.params.id// script 取参 this.$route.params.id 2.2 query和params区别 query类似 get, 跳转之后页面 url后面会拼接参数,类似?id=1, 非重要性的可以这样传, 密码之类还是用params刷新页面id还在 params类似 post, 跳转之后页面 url后面不会拼接参数 , 但是刷新页面id 会消失 3.this.$router.replace() (用法同上,push) 4. this.$router.go(n) () 33. $route和$router的区别？ $route代表的是当前路由对象，包含一些路由相关的属性，例如path，params，hash，query，fullPath，matched，name等路由信息参数。 $router代表的是VueRouter实例对象，包括了路由的跳转方法，钩子函数等。例如：push() replace() back() 34.对比 jQuery ，Vue 有什么不同​ jQuery 专注视图层，通过操作 DOM 去实现页面的一些逻辑渲染； Vue 专注于数据层，通过数据的双向绑定，最终表现在 DOM 层面，减少了 DOM 操作，Vue 使用了组件化思想，使得项目子集职责清晰，提高了开发效率，方便重复利用，便于协同开发。 35.vue是渐进式的框架的理解：(主张最少,没有多做职责之外的事)​ 主张最少，没有多做职责之外的事；每个框架都不可避免会有自己的一些特点，从而会对使用者有一定的要求，这些要求就是主张，主张有强有弱，它的强势程度会影响在业务开发中的使用方式。 ​ Vue的每个组件都是可以单独被嵌入你现有的工程中，也就是说整个工程中可以在这里使用Vue的组件系统，可以在别的地方继续使用jQuery或者其他组件，可以很好的融合至整体功能中；当然，你也可以利用Vue的整个生态系统来进行业务开发。 36.事件修饰符和按键修饰符事件修饰符 .stop：阻止冒泡 .prevent：停止默认行为 .capture：绑定到捕获阶段 .self：只能在自己身上触发 .once：只触发一次 .passive：禁止调用preventDefault 按键修饰符这是一个针对键盘事件的修饰符。 @keydown.enter = “handle()” .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 37.vue中render：h =&gt; h(App)的理解render: h =&gt; h(App)=&gt; 是es6 的箭头函数语法，并不陌生。但是h代表什么呢？跟踪源码后发现：h是createElement函数的别名，于是上面的写法等价于： 123render:function(createElement)&#123; return creatElemnt(App);&#125; createElement是一个函数，以App为参数进行调用，生成一个 VNode节点。render 函数得到这个VNode节点之后，返回给 Vue.js 的 mount 函数，渲染成真实 DOM 节点，并挂载到根节点上。 react1.redux中间件的原理是什么？ 做异步的操作在action里面去实现！需要安装redux中间件redux-thunk redux-saga redux-promise redux-thunk 目的是解决redux的异步的问题，redux中间件。 ​ 本来actionCreators只能返回对象的action，交给reducer处理，但是安装了redux-thunk中间件后，actionCreators不仅可以返回对象的action，同时内部也可以返回一个函数，函数的参数就是dispatch，就可以拿到数据后，通过手动调用dispatch({})给reducer。redux-thunk内部就判断传递过去的action是个对象还是个函数，如果是对象，走next(action)==&gt;next Middle or reducer处理，如果传递的是一个函数，那么action(dispatch,getState)在通过手动调用dispatch({})给reducer。 12345678910111213function createThunkMiddleware(extraArgument) &#123; return (&#123; dispatch, getState &#125;) =&gt; (next) =&gt; (action) =&gt; &#123; if (typeof action === &#x27;function&#x27;) &#123; return action(dispatch, getState, extraArgument); &#125; return next(action); &#125;;&#125;const thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware;export default thunk; 2.vuex和redux的区别vuex流向： view——&gt;commit——&gt;mutations——&gt;state变化——&gt;view变化（同步操作）view——&gt;dispatch——&gt;actions——&gt;mutations——&gt;state变化——&gt;view变化（异步操作） redux流向： view——&gt;actions——&gt;reducer——&gt;state变化——&gt;view变化（同步异步一样） Redux相对于Flux的改进 （1）把store和Dispatcher合并,结构更加简单清晰新增state角色，代表每个时间点store对应的值，对状态的管理更加明确Redux数据流的顺序是:（2）View调用store.dispatch发起Action-&gt;store接受Action(action传入reducer函数,reducer函数返回一个新的state)-&gt;通知store.subscribe订阅的重新渲染函数Vuex是专门为Vue设计的状态管理框架,同样基于Flux架构，并吸收了Redux的优点 Vuex相对于Redux的不同点 （1）改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch,只需在对应的mutation函数里改变state值即可（2）由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可（3）Vuex数据流的顺序是:View调用store.commit提交对应的请求到Store中对应的mutation函数-&gt;store改变(vue检测到数据变化自动渲染) 3.你会把数据统一放入到redux中管理，还是共享数据放在redux中管理？把所有的数据放入到redux中管理。(props,state) 项目一旦有问题，可以直接定位问题点。 组件扩展的时候，后续涉及到传递的问题。本来的话，自己使用数据，但是后来公用，好需要考虑如何传递。 redux中存储数据可以存储至少5G以上的数据。 4.了解redux么，说一下redux？store ：用来存储数据reducer：真正的来管理数据actionCreators：创建action，交由reducer处理view： 用来使用数据，在这里，一般用react组件来充当 redux三个原则： 单一数据流 状态是只读的 使用纯函数来修改 ​ redux是一个应用数据流框架，主要是解决了组件间状态共享的问题，原理是集中式管理。 ​ 主要有三个核心方法，action、store、reducer，工作流程 view 调用 store 的 dispatch 接受 action ，并将其传入 store ，store 内部又悄悄的传给了 reducer ，reducer 内部进行 state 操作，返回最新状态给 store ，view 通过 store 提供的 getState 获取最新的数据。 ​ Redux 和 Flux 很像。主要区别在于 Flux 有多个可以改变应用状态的 store ，在 Flux 中 dispatcher 被用来传递数据到注册的回调事件，但是在 Flux 中只能定义一个可更新状态的 store ，redux 把 store和 Dispatcher 合并，结构更加简单清晰。 5.redux有什么缺点？​ 一个组件所需要的数据，必须由父组件传过来，而不能向 flux 中直接从 store 取。 ​ 当一个组件和相关数据更新是，即使父组件不需要用到这个数据，父组件还是会重新 render ，可能会有效率影响，或者需要与复杂的 shouldComponentUpdate进行判断。 6.componentWillReceiveProps调用时机？​ 父组件第一次将数据传递给子组件的时候不会执行，只有props改变的时候，子组件的钩子函数才会被触发执行。 7.react生命周期钩子？ 初始化阶段: constructor：获取实例的默认属性、获取每个实例的初始化状态 static getDerivedStateFromProps()：组件将要接收到属性的时候调用 render：组件在这里生成虚拟的DOM节点 componentDidMount：组件真正在被装载之后 更新阶段： static getDerivedStateFromProps()：组件将要接收到属性的时候调用 shouldComponentUpdate：组件接受到新属性或者新状态的时候（可以返回false，接受数据后不更新，阻止render调用，后面的函数不会被继续执行了） render：组件重新描绘 componentDidUpdate：组件已经更新 销毁阶段： componentWillUnmount：组件即将销毁 8.react性能优化的最佳实践？shouldComponentUpdate这个钩子函数，一旦返回true组件更新操作。 shouldComponentUpdate这个方法用来判断是否需要调用render方法重新描绘dom。因为dom的描绘非常消耗性能，如果我们能在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高性能。 PureComponent纯组件自带shouldComponentUpdate，可以对props进行浅比较，发现后面的props与前面的props一样，就不会进行render了。（引用类型地址相同的话，不会render!） 123456789&lt;div&gt;&lt;Test a=&#123;10&#125;/&gt;&lt;/div&gt;class Test extends React.PureComponent&#123; constructor(props)&#123; super(props); &#125; render()&#123; return &lt;div&gt;hello...&#123;this.props.a&#125;&lt;/div&gt; &#125;&#125; React.memo()可以和函数组件一起使用提升性能 1234567891011export default React.memo(function Mome(props) &#123; console.log(111111); return ( &lt;div&gt; &lt;li&gt; &lt;input type=&quot;checkbox&quot; checked=&#123;props.item.flag&#125; onChange=&#123;props.handleChange.bind(this,props.item.id)&#125; /&gt; &#123;props.item.text&#125; &lt;/li&gt; &lt;/div&gt; )&#125;) 9. 虚拟dom是什么，为什么虚拟dom会提升代码性能？是什么​ 虚拟DOM就是JavaScript对象，就是在没有真实渲染DOM之前做的操作。​ 真实dom的比对变成了虚拟dom的比对（js对象的比对）虚拟dom里面比对，涉及到diff算法。 key值 （key值相同dom可以直接进行复用） 提升性能？​ 虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。​ 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。 10.react的diff算法 把树形结构按照层级分解，只比较同级元素。时间复杂度为n 给列表结构的每个单元添加唯一的 key 属性，方便比较。 React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字） 合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制. 选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。 11.react的keys的作用是什么？123456789render () &#123; return ( &lt;ul&gt; &#123;this.state.todoItems.map((&#123;item, key&#125;) =&gt; &#123; return &lt;li key=&#123;key&#125;&gt;&#123;item&#125;&lt;/li&gt; &#125;)&#125; &lt;/ul&gt; )&#125; ​ Keys是React用于追踪哪些列表中元素被修改、被添加或者移出的辅助标识。 ​ 开发过程中，我们需要保证某个元素的key在其同级元素中具有唯一性。在React Diff算法中React会借助元素的key值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。 ​ 此外，React还需要借助key值来判断元素与本地状态的关联关系，因此我们决不可忽视转换函数中key的重要性。 ​ 避免出错： ​ 例如：数组循环出来三项，每一项前面有一个多选框，假设第一个多选框勾选了，然后我再动态添加新的元素，会发现新添加的元素就会被勾选了，这就是个问题！key值，这样的话就可以解决了。 12.webpack中，是借助loader完成的jsx代码的转化，还是babel?​ 在vue中，借助webpack提供的vue-loader来帮助我们做一些转化，让vue代码可以在浏览器中执行。​ react中没有react-loader来进行代码的转化，而是采用babel里面babel-preset-react来实现的。 13.调用setState之后，发生什么？123456789101112constructor(props)&#123; super(props); this.state = &#123; age:1 &#125;&#125;this.setState((prevState)=&gt;(&#123; age:++prevState.age&#125;));console.log(this.state.age) ​ 通过调用this.setState去更新this.state,不能直接操作this.state，请把它当成不可变的。​ 调用setState更新this.state,他不是马上就会生效的，他是异步的。所以不要认为调用完setState后可以立马获取到最新的值。​ 多个顺序执行的setState不是同步的一个接着一个的执行，会加入一个异步队列，然后最后一起执行，即批处理。 ​ setState是异步的，导致获取dom可能拿的还是之前的内容，所以我们需要在setState第二个参数（回调函数）中获取更新后的新的内容。 12345this.setState((prevState)=&gt;(&#123; age:++prevState.age&#125;),()=&gt;&#123; console.log(this.state.age) //获取更新后的最新的值&#125;); 14.（组件的）状态（state）和属性（props）之间有何不同？​ state是一种数据结构，用于组件挂载时所需数据的默认值。state可能会随着时间的推移而发生突变，但多数时候时作为用户事件行为的结果。 ​ props则是组件的配置。props由父组件传递给子组件，并且就子组件而言，props是不可变的**(immutable)。组件不能改变自身的props放在一起(统一管理)。props也不仅仅是数据–回调函数也可以通过props**传递。 15. refs的作用业务场景？12345678910111213141516171819//例如获取图片的宽度与高度。 &lt;input ref=&#123;el=&gt;this.input = el&#125;/&gt;class Test extends React.Component&#123; constructor(props)&#123; super(props); this.handleWidowScroll = this.handleWidowScroll.bind(this); &#125; handleWidowScroll()&#123; this.setState(&#123; top:document.body.scrollTop &#125;) &#125; componentDidMount()&#123; window.addEventListener(&quot;scroll&quot;,this.handleWindowScroll); &#125; componentWillUnmount()&#123; window.removeEventListener(&quot;scroll&quot;,this.handleWindowScroll); &#125;&#125; 16. ref是一个函数，为什么？123456789class Test extends React.Component&#123; componentDidMount()&#123; console.log(this.el); &#125; render()&#123; //react在销毁组件的时候会帮助我们清空掉ref的相关引用，这样可以防止内存泄漏等一系列问题。 return &lt;div ref=&#123;el=&gt;this.el=el&#125;&gt;&lt;/div&gt; &#125;&#125; 17. 高阶组件是什么？如何理解?​ 高阶组件就是一个对普通组件的包装，并返回一个新的组件。本质上就是一个函数。​ react-redux connect==&gt;容器组件 connect()(ui组件)​ @withRouter/withRouter(App) ​ 高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。 18.react 组件的划分业务组件技术组件？ 根据组件的职责通常把组件分为 UI 组件和容器组件。 UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。 两者通过 React-Redux 提供 connect 方法联系起来。 19. 受控组件与非受控组件的区别?受控组件： 受到数据的控制。组件的变化依靠数据的变化，数据变化了，页面也会跟着变化了。 12&lt;input value=&#123;this.state.value&#125;/&gt;输入框收到数据的控制，数据只要不变化，input框输什么都不行。 非受控组件： 直接操作dom，不做数据的绑定。通过refs来获取dom上的内容进行相关的操作。 1&lt;input ref=&#123;el=&gt;this.el=el&#125;/&gt; react==&gt;数据驱动是react核心。 ​ 包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 onChange 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为”受控元素”。 20.哪个生命周期里面发送ajax?vue：created、mount AJAX请求应该在componentDidMount生命周期事件中。 componentWillMount在React最新的版本里面已经被废弃了。 React 下一代调和算法 Fiber 会通过开始或停止渲染的方式优化应用性能，其会影响到 componentWillMount 的触发次数。对于 componentWillMount 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 componentWillMount。如果我们将 AJAX 请求放到 componentWillMount 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。 （fiber or diff算法区别 ） 21.react,jquey,vue是否可以共存在一个项目中？123&lt;div&gt;&lt;/div&gt;&lt;div id=&quot;react&quot;&gt;&lt;/div&gt;&lt;div id=&quot;vue&quot;&gt;&lt;/div&gt; 12ReactDOM.render(&lt;App/&gt;,document.getElementById(&quot;react&quot;));new Vue(&#123;el:&quot;#vue&quot;,router,store&#125;); 22.组件是什么？类是什么？类被编译成什么？模块：在webpack中，通过import引入的文件叫做模块。（js/css/png）函数：是一些功能的合集。组件：指的是页面的某一部分。 12345678910//super作用 https://blog.csdn.net/qq_41709082/article/details/86573720class Banner extends React.Component&#123; //es6写法 constrcutor()&#123; super() //关键字作用？ 可以使用this super() 调用父类构造方法 &#125;&#125;function Banner()&#123; //构造函数&#125; es6 class es5 function 关系? class怎么用的？ 23.类组件与函数式组件区别？ 函数组件和类组件当然是有区别的，而且函数组件的性能比类组件的性能要高， 因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。 为了提高性能，尽量使用函数组件。 函数组件没有this,没有生命周期，没有状态state, 类组件有this,有生命周期，有状态state。 24.模块化规范​ 模块化规范： amd cmd (异步加载 用在浏览器端) commonjs 规范 ​ 其实CMD与AMD规范并没什么本质的区别，区别在于他们对依赖模块的执行时机处理不同。虽然两者都是异步加载模块，但是AMD依赖前置，js可以方便知道依赖模块是谁，要依赖什么js那就先加载进来，至于你要依赖这些js来干吗得先等着，等我加载完了资源再商量;而CMD就近依赖，需要使用这个依赖模块时，我再加载进来用。 ​ 这就好比什么呢?就好像我今晚要看5集三国演义。AMD是先打开五个窗口，分别是1~5集，都缓冲着先，反正等下每集我都要看的;CMD则是先打开第一集的窗口，等到我第一集看完了，想看第二集了，就再跳转到第二集。 ​ 现在使用频率最高的，也是大家公认的好的模块化规范，是CommonJS。 后端（node.js） ​ CommonJS就很简单了，一个js文件要输出去，只需使用module.export={xxx:你要输出的内容}，而在另外一个js中，你要引用什么，就通过var xxxx=require(“xxxx”)引用进来就行了，这玩意并不是异步加载模块，而是同步一次性加载出来。 https://blog.csdn.net/qq_25800235/article/details/83379287 25. 如何避免ajax数据重新获取？将所有的数据存储在redux中进行管理，既可以解决该问题。 26. react-router的核心思想是什么？react-router-dom 5.2.1 路由也变成组件了，所以它是非常灵活的(NavLink Route)。 vue中的路由需要单独的配置 vue-router 27.react-router的两种模式是什么？区别是什么？hashHistory # 不需要后端服务器的配置browserHistory / 需要后端服务器的配置 （后端人员不清楚路由重定向等相关的概念） hash路由： hash模式背后的原理是onhashchange事件，可以在window对象上监听这个事件： 12345window.onhashchange &#x3D; function(event) &#123; console.log(event.oldURL, event.newURL); let hash &#x3D; loaction.hash &#x2F;&#x2F;通过location对象来获取hash地址 console.log(hash) &#x2F;&#x2F; &quot;#&#x2F;notebooks&#x2F;260827&#x2F;list&quot; 从#号开始&#125; 因为hash发生变化的url都会被浏览器记录下来，从而你会发现浏览器的前进后退都可以用 这样一来，尽管浏览器没有请求服务器，但是页面状态和url一一关联起来，后来人们给它起了一个霸气的名字叫前端路由，成为了单页应用标配。 history路由​ 随着history api的到来，前端路由开始进化了，前面的hashchange，你只能改变#后面的url片段，而history api则给了前端完全的自由 history api可以分为两大部分：切换和修改 ​ （1）切换历史状态 ​ 包括括 back、forward、go三个方法，对应浏览器的前进，后退，跳转操作 1234history.go(-2);&#x2F;&#x2F;后退两次history.go(2);&#x2F;&#x2F;前进两次history.back(); &#x2F;&#x2F;后退hsitory.forward(); &#x2F;&#x2F;前进 ​ （2）修改历史状态 ​ 包括 了pushState、replaceState两个方法，这两个方法接收三个参数：stateObj，title，url 在hash模式下，前端路由修改的是#中的信息，而浏览器请求时是不带它玩的，所以没有问题。但是在history下，你可以自由的修改path，当刷新时，如果服务器中没有相应的响应或者资源，会分分钟刷出一个404来。 https://www.jianshu.com/p/81ccd1124f48 28. react与vue之间的区别？相同点： ​ 1.都支持服务器端渲染 ​ 2.都有Virtual DOM,组件化开发,通过props参数进行父子组件数据的传递,都实现webComponent规范 ​ 3.数据驱动视图 ​ 4.都有支持native的方案,React的React native,Vue的weex ​ 5.都有管理状态，React有redux,Vue有自己的Vuex（自适应vue，量身定做） 不同点： ​ 1.React严格上只针对MVC的view层,Vue则是MVVM模式 ​ 2.virtual DOM不一样 ​ vue会跟踪每一个组件的依赖关系,不需要重新渲染整个组件树. ​ 而对于React而言,每当应用的状态被改变时,全部组件都会重新渲染,所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制 ​ 3.组件写法不一样。 ​ React推荐的做法是 JSX + inline style, 也就是把HTML和CSS全都写进JavaScript了,即’all in js’; ​ Vue推荐的做法是webpack+vue-loader的单文件组件格式,即html,css,js写在同一个文件; ​ 4.数据绑定: vue实现了数据的双向绑定,react没有实现 ​ 5.state对象在react应用中不可变的,需要使用setState方法更新状态; ​ 在vue中,state对象不是必须的,数据由data属性在vue对象中管理； ​ React Fiber是react执行渲染时的一种新的调度策略，JavaScript是单线程的，一旦组件开始更新，主线程就一直被React控制，这个时候如果再次执行交互操作，就会卡顿。 ​ React Fiber重构这种方式，渲染过程采用切片的方式，每执行一会儿，就歇一会儿。如果有优先级更高的任务到来以后呢，就会先去执行，降低页面发生卡顿的可能性，使得React对动画等实时性要求较高的场景体验更好。 nodejs1.编写代码实现遍历文件1234567891011121314151617const fs &#x3D; require(&quot;fs&quot;)const path &#x3D; require(&quot;path&quot;)const readDir &#x3D; (entry)&#x3D;&gt;&#123; const dirInfo &#x3D; fs.readdirSync(entry) &#x2F;&#x2F;[&quot;hello&quot;,&quot;node.js&quot;] dirInfo.forEach(item&#x3D;&gt;&#123; const location &#x3D; path.join(entry,item) &#x2F;&#x2F;需要判断这个路径是文件夹还是文件 const info &#x3D; fs.statSync(location) if(info.isDirectory())&#123; &#x2F;&#x2F;如果是文件夹的话，就进来了 hello console.log(&#96;dir:$&#123;location&#125;&#96;) readDir(location) &#x2F;&#x2F;递归的方式实现遍历 &#125;else&#123; console.log(&#96;file:$&#123;location&#125;&#96;) &#125; &#125;)&#125;readDir(__dirname) 2.node如何做版本升级？为什么要使用nvm回答node相关的内容的时候，尽量不要发挥到全栈。 引导到webpack上、npm上，前端工程化方向做功 为何做node的版本升级？现在使用node8 12.x 升级版本的目的： 1.12.x有些新的语法api出现了，在当前的8.x的版本不支持 2.webpack做项目过程中，希望它可以打包速度变快，所以需要升级node版本 npm install nvm -g nvm ls (列出所有的node的版本号) nvm use v12.0.0 node -v(查看当前安装的node版本) 3.模块化的差异 amd commonjs esmoduleamd是requireJS在推广过程中对模块的规范化产出，是一个概念。 amd推崇依赖前置 —&gt; 依赖必须一开始就要写好 （生活的案例，打开3个标签页，每个标签页提前放好1，2，3集） 12345define([&#x27;./a&#x27;,&#x27;./b&#x27;],function(a,b)&#123; a.doSomething() //写了100行代码 b.doSomething()&#125;) cmd 是 seaJS在推广过程中对模块定义的规范化的产出 cmd推崇依赖就近—&gt;内部用到某个依赖模块了再去进行单独的引入 1234567891011121314151617define(function(require,exports,module)&#123; var a = require(&quot;./a&quot;) a.doSomething() //写了100行代码 var b = require(&quot;./b&quot;) b.doSomething()&#125;)//跟esmodule的区别if(true)&#123; //这句代码是否可行？这是不行的！不能在逻辑里面通过这种方式引入代码 //静态引入 webpack内部推荐esmodule的方式引入模块，内部打包速度快 import a from &quot;a&quot; //amd.cmd这种方式称之为动态引入，可以根据逻辑引入不同的功能模块 require(&quot;./a&quot;) //这句代码是可行的&#125; 4.图片上传到服务器流程（FileReader.readAsDataURL） onchange后，内部你就可以调用FileReader.readAsDataURL获取你所上传的图片的base64的内容， 放入到img标签里面，实现图片的预览效果 5.node里面的mvc的理解m:model 数据模型层 （数据与数据库的操作的一部分逻辑 增删查改操作 java/dao层） v:view 视图层 c:controller 控制器 c的作用是将m层的数据在v层上进行显示。 mvc三层是可以互相的调用，流程上没有过多的限制 mvp是mvc的升级，m不能调用p层，v也不能去调用p层，只有p层可以调用mv.最终暴露用户的是p这一层 mvvm m:model v:view vm:viewmodel vm层可以感知数据的变化，然后实时的渲染最新的视图，并且这个是自动的操作。（Object.defineProperty） react只是mvc里面的v层。因为当数据发生变化了，视图是不会渲染最新视图，必须内部调用setState进行更新， 然后视图才可以变成最新的视图。 这个操作是我们手动实现的。 6.常用的css预处理语言less or sass (stylus ) less底层是js进行编译的 sass底层是ruby进行编译的 （node-sass sass-loader） 命名空间可以避免一些冲突问题的产生： 12345.home&#123; .home-header&#123;&#125; .home-content&#123;&#125;&#125;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt; 7.工程化上的按需加载说白了就是异步组件。 vue里面的vue-router生态里面，实现路由的懒加载的时候，通过 12345new VueRouter(&#123; routes:[ &#123;component:()=&gt;import(&quot;XXX&quot;),path:&quot;/home&quot;&#125; ]&#125;) vue中的路由采用了异步组件+webpack的代码分割功能实现了路由的懒加载，减少首页的加载用时 react里面实现懒加载的话，怎么做？ 通过使用react-loadable的第三方模块，实现懒加载 8.node中的npm与版本管理（package.lock / yarn.lock)cnpm i axios -S package.lock/yarn.lock 称之为版本锁文件 本地测试是没有问题的，然后发布线上有问题了，例如发布线上的时候axios由1.0变成了2.0了 api内部肯定不一样的，所以就会导致线上报错的问题。 版本锁文件的出现，就是锁住当前的版本，避免出错。 （npm 5.x以上就会有） 9.Webpack常用插件与loader核心概念： entry output (hash chunkHash:8) loader plugins loader: ​ css-loader(处理图片路径、将css样式进行打包到js文件中) ​ style-loader:通过style标签将css插入到dom中，通过与css-loader进行搭配使用 ​ postcss-loader:添加样式前缀，解决部分css兼容问题 ​ sass-loader 加载sass编译为css ​ vue-loader允许以一种单文件组件的形式去编写vue组件 ​ file-loader 处理文件或图片（url-loader） plugins: ​ html-webpack-plugin插件 （template模板） ​ 将打包后的文件自动插入到指定的模板里面去 ​ extract-text-webpack-plugin ​ 将打包后的css单独进行抽离 ​ optimize-css-assets-webpack-plugin ​ 压缩css，优化css结构，利于网页的加载与宣传 ​ copy-webpack-plugin ​ 将指定目录下的文件赋值到指定目录下 ​ ​ happypak ​ 多线程的执行任务，加快编译速度 打包后的文件”*.map”作用？如何干掉？ 打包后的后缀名为map的文件是由于配置了souremap选项产生的，打包后的文件不容易找到出bug对应的源码的位置。所以通过sourcemap就可以帮助我们解决此问题，有了map就可以像未压缩的代码一样，准确的输出是哪一行那一列有错误。 config/index.js文件中修改参数即可： productionSoureMap:false webpack中通过proxy配置反向代理？ 为了解决前后端联调时出现的跨域问题，将后端的域名的请求代理到本地，从而避免跨域请求。 1234567&quot;/api&quot;:&#123; target:&quot;http://www.XXXX&quot;， //要访问的真实域名接口 changeOrigin:true, //是否跨域 pathRewrite:&#123; //在代理过程中是否需要替换掉/api/路径 &quot;^/api&quot;:&quot;&quot; &#125;&#125; 10. mongodb数据库操作常用命令mongodb vs mysql mongodb 开机：mongod –dbpath 路径 连接数据库（一定要在开机的情况下调用此命令）：mongo 查看所有数据库：show dbs 查看当前数据库（后续的操作对当前数据库生效）：db 切换/创建数据库：use 数据库名 插入数据：db.集合名.insert({username:”xiaoxiao”,password:”123456”}) 查询数据：db.集合名.find(“条件对象”).pretty() .pretty()：漂亮的展示在控制台中。 修改数据：db.users.update({username:”xiaoxiao”},{$set:{username:”weixiao”}}) 删除数据：db.集合名.remove(条件对象) git1.git基本命令 git add 将想要快照的内容写入缓存区 git status -s “AM” 状态的意思是，这个文件在我们将它添加到缓存之后又有改动 git commit -m ‘第一次版本提交’ -m选项添加备注信息 git clone url 使用 git clone 拷贝一个 Git 仓库到本地 git diff 查看执行 git status 的结果的详细信息 git reset HEAD 用于取消已缓存的内容 git rm file git rm 会将条目从缓存区中移除。这与 git reset HEAD 将条目取消缓存是有区别的。 “取消缓存”的意思就是将缓存区恢复为我们做出修改之前的样子。 默认情况下，git rm file 会将文件从缓存区和你的硬盘中（工作目录）删除。 git mv 重命名磁盘上的文件 如 git mv README README.md git push -u origin master 提交代码 2.git 分支管理 创建分支命令 git branch (branchname) 列出分支 git branch 切换分支命令 git checkout (branchname) 合并分支 git merge (branchname) –no-ff：记录历史 创建新分支并立即切换到该分支下 git checkout -b (branchname) 删除分支命令 git branch -d (branchname) 3.查看日志版本 git log 命令列出历史提交记录 git log –oneline 查看历史记录的简洁的版本 git log –oneline –graph 查看历史中什么时候出现了分支、合并 4.SVN与Git优缺点比较（属面试题常提问）SVN优缺点 优点： 管理方便，逻辑明确，符合一般人思维习惯。 易于管理，集中式服务器更能保证安全性。 代码一致性非常高。 适合开发人数不多的项目开发。缺点： 服务器压力太大，数据库容量暴增。 如果不能连接到服务器上，基本上不可以工作，看上面第二步，如果服务器不能连接上，就不能提交，还原，对比等等。 不适合开源开发（开发人数非常非常多，但是Google app engine就是用svn的）。但是一般集中式管理的有非常明确的权限管理机制（例如分支访问限制），可以实现分层管理，从而很好的解决开发人数众多的问题。 Git优缺点优点： 适合分布式开发，强调个体。 公共服务器压力和数据量都不会太大。 速度快、灵活。 任意两个开发者之间可以很容易的解决冲突。 离线工作。 缺点： 学习周期相对而言比较长。 不符合常规思维。 代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。 5.git提交时冲突问题解决用git 提交项目时正确的操作应该是 12345678git status &#x2F;&#x2F;查看改动git add . &#x2F;&#x2F;添加到本地仓库git commit -m:&quot;备注&quot; &#x2F;&#x2F;提交git pull --rebase origin xxx &#x2F;&#x2F;从远程仓库拉项目git status &#x2F;&#x2F;再看看是不是一样的git push origin xxx &#x2F;&#x2F;提交到远程仓库 &#x2F;&#x2F;gitlab的话还得登录gitlab账号去create merge request 然而我们改动完项目提交时，有时候会遇到冲突的情况 12error: Failed to merge in the changes.Using index info to reconstruct a base tree... 有这样的提示 这个时候用编辑器或IDE找出出现冲突的地方，看看留下服务器端的还是自己改的。改完之后进行以下操作 1234567git add .git commit -m:&quot;xxx&quot;git rebase --continuegit statusgit push origin xxx&#x2F;&#x2F;如果冲突已经解决完了的话，这里不会出意外 webpack1.wabpack之loader加载顺序从右到左compose 2.babel工作原理3.webpack性能优化小程序1.小程序的登录需要请求几次？ 请求wx.login，返回code 发送code，返回openid+sessionKey 请求getuserinfo（用户信息） 2.小程序怎样使用自定义组件？首先需要在 json 文件中进行自定义组件声明 123&#123; &quot;component&quot;:true&#125; 然后在自定义组件的 js 文件中，需要使用 Component()来注册组件；使用时在页面的 json文件中进行引用声明。此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径： 12345&#123; &quot;usingComponents&quot;:&#123; &quot;component-tag-name&quot;:&quot;path/to/the/custom/component&quot; &#125;&#125; 3.小程序的生命周期 onLoad() 页面加载时触发，只会调用一次，可获取当前页面路径中的参数。 onShow() 页面显示/切入前台时触发，一般用来发送数据请求； onReady() 页面初次渲染完成时触发, 只会调用一次，代表页面已可和视图层进行交互。 onHide() 页面隐藏/切入后台时触发, 如底部 tab 切换到其他页面或小程序切入后台等。 onUnload() 页面卸载时触发，如redirectTo或navigateBack到其他页面时。 4.小程序是双向数据绑定吗？怎么更新data不是， 用setData（）更新 5.小程序本地存储有哪些常用api？ 6.wx.navigateTo和 wx.redirectTo 有什么区别，分别适用于哪些场景 使用wx.navigateTo每新开一个页面，页面栈大小加1，使用wx.navigateTo重复打页面也会增加页面栈 使用wx.redirectTo会关闭当前页面打开新页面，页面栈大小不变 对于可逆操作，使用wx.navigateTo,比如从首页跳转到二级页面，从二级页面返回是不需要重新渲染首页 对于不可逆操作，使用wx.redirectTo,比如用户登录成功后，关闭登录页面，不能返回到登录界面。 不要在首页使用wx.redirectTo，这样会导致应用无法返回首页 7.简单描述下微信小程序的相关文件类型？微信小程序项目结构主要有四个文件类型,如下： WXML （WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件。 WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式 js 逻辑处理，网络请求 json 小程序设置，如页面注册，页面标题及tabBar。 app.json 必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的window背景色，配置导航条样式，配置默认标题。 app.js 必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。 app.wxss 全局样式 8.你使用过哪些方法，来提高微信小程序的应用速度？ 提高页面加载速度 用户行为预测 减少默认data的大小 组件化方案 9.小程序与原生App哪个好？小程序除了拥有公众号的低开发成本、低获客成本低以及无需下载等优势，在服务请求延时与用户使用体验是都得到了较大幅度 的提升，使得其能够承载跟复杂的服务功能以及使用户获得更好的用户体验。 10.分析下微信小程序的优劣势？优势 无需下载，通过搜索和扫一扫就可以打开。 良好的用户体验：打开速度快。 开发成本要比App要低。 安卓上可以添加到桌面，与原生App差不多。 为用户提供良好的安全保障。小程序的发布，微信拥有一套严格的审查流程， 不能通过审查的小程序是无法发布到线上的。 劣势 限制较多。页面大小不能超过1M。不能打开超过5个层级的页面。 样式单一。小程序的部分组件已经是成型的了，样式不可以修改。例如：幻灯片、导航。 推广面窄，不能分享朋友圈，只能通过分享给朋友，附近小程序推广。其中附近小程序也受到微信的限制。 依托于微信，无法开发后台管理功能。 11.微信小程序与H5的区别？ 运行环境不同；传统的HTML5的运行环境是浏览器，包括webview，而微信小程序的运行环境并非完整的浏览器，是微信开发团队基于浏览器内核完全重构的一个内置解析器，针对小程序专门做了优化，配合自己定义的开发语言标准，提升了小程序的性能。 开发成本不同；只在微信中运行，所以不用再去顾虑浏览器兼容性，不用担心生产环境中出现不可预料的奇妙BUG 获取系统级权限不同；系统级权限都可以和微信小程序无缝衔接 应用在生产环境运行的流畅度；长久以来，当HTML5应用面对复杂的业务逻辑或者丰富的页面交互时，它的体验总是不尽人意，需要不断的对项目优化来提升用户体验。但是由于微信小程序运行环境独立 12.怎么解决小程序的异步请求问题？在回调函数中调用下一个组件的函数：app.js 123success: function (info) &#123; that.apirtnCallback(info)&#125; index.js 12345onLoad: function () &#123; app.apirtnCallback = res =&gt; &#123; console.log(res) &#125;&#125;","categories":[],"tags":[]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2021-01-01T05:12:45.000Z","updated":"2021-01-01T05:15:34.760Z","comments":true,"path":"2021/01/01/我的第一篇博客文章/","link":"","permalink":"http://example.com/2021/01/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"第一章内容 第二章内容 参考文件81.70.205.12:4000","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-01-01T05:10:13.155Z","updated":"2021-01-01T05:10:13.156Z","comments":true,"path":"2021/01/01/hello-world/","link":"","permalink":"http://example.com/2021/01/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}